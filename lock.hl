(* ========================================================================= *)
(* Semicertified interactive logic programming.                              *)
(*                                                                           *)
(* Copyright (c) 2017-2019 Marco Maggesi, Massimo Nocentini                  *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Examples from The Mystery of the Monte Carlo Lock.                        *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Miscellanea on lists.                                                     *)
(* ------------------------------------------------------------------------- *)

g `!l:A list. l = APPEND [] l`;;
e (REWRITE_TAC[APPEND]);;
let REFL_APPEND_NIL = top_thm();;

g `!h:A t t' l1 l2.
     l1 = CONS h t' /\ t = APPEND t' l2 ==> CONS h t = APPEND l1 l2`;;
e (REPEAT STRIP_TAC THEN REPEAT (FIRST_X_ASSUM SUBST_VAR_TAC));;
e (REWRITE_TAC[APPEND]);;
let CONS_EQ_APPEND = top_thm();;

(* ------------------------------------------------------------------------- *)
(* First example.                                                            *)
(* ------------------------------------------------------------------------- *)

let LOCK_RULES,LOCK_INDUCT,LOCK_CASES = new_inductive_definition
  `(!x. LOCK (CONS 2 x) x) /\
   (!x y. LOCK x y ==> LOCK (CONS 3 x) (APPEND y (CONS 2 y)))`;;

let LOCK_RULE1,LOCK_RULE2 = CONJ_PAIR LOCK_RULES;;

g `!x y z. LOCK x y /\ z = APPEND y (CONS 2 y) ==> LOCK (CONS 3 x) z`;;
e (MESON_TAC[LOCK_RULE2]);;
let LOCK_RULE2' = top_thm();;

(* ------------------------------------------------------------------------- *)
(* Solution using tactics.                                                   *)
(* ------------------------------------------------------------------------- *)

g `LOCK [3;2;3] [3;2;3]`;;
e (MATCH_MP_TAC LOCK_RULE2');;
e (EXISTS_TAC `[3]`);;
e (REWRITE_TAC[APPEND]);;
e (MATCH_ACCEPT_TAC LOCK_RULE1);;
top_thm();;

MESON
  [LOCK_RULES; APPEND]
  `LOCK [3;2;3] [3;2;3]`;;

METIS
  [LOCK_RULES; APPEND]
  `LOCK [3;2;3] [3;2;3]`;;

(* ------------------------------------------------------------------------- *)
(* Solution using solvers.                                                   *)
(* ------------------------------------------------------------------------- *)

gg `??x. LOCK x x`;;
ee (APPLY_SLV LOCK_RULE1);;
bb();;
ee (APPLY_SLV LOCK_RULE2);;
bb();;
ee (APPLY_SLV LOCK_RULE2');;
tt CONJ_TAC;;
ee (APPLY_SLV LOCK_RULE1);;
ee (APPLY_SLV CONS_EQ_APPEND);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV REFL_APPEND_NIL);;
top_thm1();;

let STEP_SLV : solver =
  COLLECT_SLV
    [TACTIC_SLV CONJ_TAC;
     REFL_SLV;
     ACCEPT_SLV LOCK_RULE1;
     RULE_SLV LOCK_RULE2';
     ACCEPT_SLV REFL_APPEND_NIL;
     RULE_SLV CONS_EQ_APPEND];;

let rec SEARCH_SLV : solver =
  REPEAT_SLV STEP_SLV;;

gg `??x. LOCK x x`;;
ee SEARCH_SLV;;
let sols = top_thms();;

(* Alternative method. *)
let rec SEARCH_ALT_SLV : solver =
  fun g -> CONCAT_SLV (TACTIC_SLV ALL_TAC)
                      (THEN_SLV STEP_SLV SEARCH_SLV) g;;

gg `??x. LOCK x x`;;
ee SEARCH_ALT_SLV;;

let default : 'a option -> 'a =
  function
      Some x -> x
    | None -> failwith "default";;

let sols = stream_mapfilter default (top_thms ());;
(* [3;2;3] Ã¨ l'unico punto fisso, se cerchiamo altre soluzioni diverge.
   drop 1 sols;;
*)


(* ------------------------------------------------------------------------- *)
(* Second example.                                                           *)
(*                                                                           *)
(* M-I:   For any number X,  2X2 produces X.                                 *)
(* M-II:  If X produces Y, then 6X produces 2Y.                              *)
(* M-III: If X produces Y, then 4X produces REVERSE Y.                       *)
(* M-IV:  If X produces Y, then 5X produces YY.                              *)
(* ------------------------------------------------------------------------- *)

let LOCK2_RULES,LOCK2_INDUCT,LOCK2_CASES = new_inductive_definition
  `(!x. LOCK2 (CONS 2 (APPEND x [2])) x) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 6 x) (CONS 2 y)) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 4 x) (REVERSE y)) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 5 x) (APPEND y y))`;;

let [L1;L2;L3;L4] = CONJUNCTS LOCK2_RULES;;

let L3' = prove
 (`!x y z. z = REVERSE y /\ LOCK2 x y ==> LOCK2 (CONS 4 x) z`,
  MESON_TAC[L3]);;

let L4' = prove
 (`!x y z. z = APPEND y y /\ LOCK2 x y ==> LOCK2 (CONS 5 x) z`,
  MESON_TAC[L4]);;

g `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
e (SUBGOAL_THEN `[5;4;6;4;2;5;4;6;4;2] = APPEND [5;4;6;4;2] [5;4;6;4;2]`
     (fun th -> GEN_REWRITE_TAC RAND_CONV [th]));;
e (REWRITE_TAC[APPEND]);;
e (MATCH_MP_TAC L4');;
e (EXISTS_TAC `[5;4;6;4;2]`);;
e CONJ_TAC;;
e REFL_TAC;;
e (GEN_REWRITE_TAC RAND_CONV [GSYM (REWRITE_CONV [REVERSE; APPEND]
     `REVERSE [2;4;6;4;5]`)]);;
e (MATCH_MP_TAC L3);;
e (MATCH_MP_TAC L2);;
e (GEN_REWRITE_TAC RAND_CONV [GSYM (REWRITE_CONV [REVERSE; APPEND]
     `REVERSE [5;4;6;4]`)]);;
e (MATCH_MP_TAC L3);;
e (GEN_REWRITE_TAC LAND_CONV [GSYM (REWRITE_CONV [APPEND]
     `(CONS 2 (APPEND [5;4;6;4] [2]))`)]);;
e (MATCH_ACCEPT_TAC L1);;
top_thm();;

let LIST_EQ_SLV : solver =
  REPEAT_SLV
    (COLLECT_SLV
       [REFL_SLV;
        APPLY_SLV REFL_APPEND_NIL;
        APPLY_SLV CONS_EQ_APPEND;
        TACTIC_SLV ALL_TAC]);;

let L4'_SLV : solver =
  THEN_SLV (APPLY_SLV L4')
           (THENL_SLV (TACTIC_SLV CONJ_TAC)
                      [TACTIC_SLV ALL_TAC;
                       LIST_EQ_SLV]);;

let CONS_EQ_APPEND_SLV : solver =
  THENL_SLV
     (TACTIC_SLV
        (MATCH_MP_TAC CONS_EQ_APPEND THEN
         META_EXISTS_TAC THEN
         CONJ_TAC))
  [REFL_SLV; TACTIC_SLV ALL_TAC];;

let LIST_CLAUSES = prove
 (`(!l1 l2:A list. l1 = [] /\ l2 = [] ==> APPEND l1 l2 = []) /\
   (!l1 l2:A list. l1 = [] /\ l2 = [] ==> [] = APPEND l1 l2) /\
   (!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> CONS h t = APPEND l1 l2) /\
   (!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> APPEND l1 l2 = CONS h t) /\
   (!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> APPEND l1 l2 = CONS h t) /\
   (!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> CONS h t = APPEND l1 l2) /\
   (!l1 l2 m1 m2 x:A list. APPEND l1 l2 = x /\ APPEND m1 m2 = x ==> APPEND l1 l2 = APPEND m1 m2)`,
  SIMP_TAC[APPEND]);;

let LIST_LEMMAS = CONJUNCTS LIST_CLAUSES;;

(* TODO: Serve? *)
let REVERSE_CLAUSES_ALT = prove
 (`(!l:A list. l = [] ==> l = REVERSE []) /\
  (!h:A t l s. APPEND s [h] = l /\ s = REVERSE t ==> l = REVERSE (CONS h t))`,
  CONJ_TAC THENL
  [MESON_TAC[REVERSE_EQ_EMPTY];
   REWRITE_TAC[REVERSE] THEN MESON_TAC[]]);;

let REVERSE_CLAUSES = prove
 (`(!l:A list. l = [] ==> [] = REVERSE l) /\
   (!l h:A t s. l = APPEND s [h] /\ t = REVERSE s ==> CONS h t = REVERSE l)`,
  CONJ_TAC THENL
  [MESON_TAC[REVERSE_EQ_EMPTY]; ALL_TAC] THEN
  LIST_INDUCT_TAC THENL
  [MESON_TAC[APPEND_EQ_NIL; NOT_CONS_NIL]; ALL_TAC] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[REVERSE] THEN
  POP_ASSUM MP_TAC THEN
  STRUCT_CASES_TAC (ISPEC `t:A list` list_CASES) THEN
  STRUCT_CASES_TAC (ISPEC `s:A list` list_CASES) THEN
  REWRITE_TAC[REVERSE; APPEND; CONS_11] THEN
  MESON_TAC[APPEND_EQ_NIL; NOT_CONS_NIL; APPEND]);;

let REVERSE_LEMMAS = CONJUNCTS REVERSE_CLAUSES;;

let FALSE_SLV : solver =
  fun (_,(_,w)) as mgl ->
    if w = `F` then Empty else TACTIC_SLV ALL_TAC mgl;;

let LIST_SIMPL_SLV : solver =
  THEN_SLV (TACTIC_SLV
             (REWRITE_TAC[APPEND; REVERSE;
                          APPEND_EQ_NIL; REVERSE_EQ_EMPTY;
                          CONS_11; NOT_CONS_NIL]))
           (THEN_SLV FALSE_SLV
                     (TACTIC_SLV (REPEAT CONJ_TAC)));;

let LIST_EQ_STEP_SLV : solver =
  THEN_SLV LIST_SIMPL_SLV
    (CONCAT_SLV
       REFL_SLV
       (THEN_SLV (MAP_COLLECT_SLV APPLY_SLV (LIST_LEMMAS @ REVERSE_LEMMAS))
                 (TACTIC_SLV CONJ_TAC)));;

let LIST_EQ_SLV : solver =
  THEN_SLV (REPEAT_SLV LIST_EQ_STEP_SLV)
           LIST_SIMPL_SLV;;

gg `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
tt (MATCH_MP_TAC L4' THEN META_EXISTS_TAC THEN CONJ_TAC);;
ee LIST_EQ_SLV;;
tt (MATCH_MP_TAC L3' THEN META_EXISTS_TAC THEN CONJ_TAC);;
ee LIST_EQ_STEP_SLV;;
ee LIST_EQ_SLV;;
ee LIST_EQ_STEP_SLV;;
ee LIST_EQ_SLV;;
ee LIST_EQ_STEP_SLV;;
ee LIST_EQ_SLV;;
ee LIST_EQ_STEP_SLV;;
ee LIST_EQ_SLV;;
ee LIST_EQ_STEP_SLV;;
ee LIST_EQ_SLV;;

ee LIST_SIMPL_SLV;;


ee (L4'_SLV);;
ee (THENL_SLV (TACTIC_SLV CONJ_TAC)
    [TACTIC_SLV ALL_TAC;
     THENL_SLV (APPLY_SLV CONS_EQ_APPEND)
        [REFL_SLV;
         APPLY_SLV CONS_EQ_APPEND]]);;


MESON
  [LOCK2_RULES; REVERSE; APPEND; REFL_APPEND_NIL; CONS_EQ_APPEND]
  `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;

METIS
  [LOCK2_RULES; REVERSE; APPEND; REFL_APPEND_NIL; CONS_EQ_APPEND]
  `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;