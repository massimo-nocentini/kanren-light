(* ========================================================================= *)
(* Semicertified interactive logic programming.                              *)
(*                                                                           *)
(* Copyright (c) 2017-2019 Marco Maggesi, Massimo Nocentini                  *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Examples from The Mystery of the Monte Carlo Lock.                        *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Miscellanea on lists.                                                     *)
(* ------------------------------------------------------------------------- *)

g `!l:A list. l = APPEND [] l`;;
e (REWRITE_TAC[APPEND]);;
let REFL_APPEND_NIL = top_thm();;

g `!h:A t t' l1 l2.
     l1 = CONS h t' /\ t = APPEND t' l2 ==> CONS h t = APPEND l1 l2`;;
e (REPEAT STRIP_TAC THEN REPEAT (FIRST_X_ASSUM SUBST_VAR_TAC));;
e (REWRITE_TAC[APPEND]);;
let CONS_EQ_APPEND = top_thm();;

(* ------------------------------------------------------------------------- *)
(* First example.                                                            *)
(* ------------------------------------------------------------------------- *)

let LOCK_RULES,LOCK_INDUCT,LOCK_CASES = new_inductive_definition
  `(!x. LOCK (CONS 2 x) x) /\
   (!x y. LOCK x y ==> LOCK (CONS 3 x) (APPEND y (CONS 2 y)))`;;

let LOCK_RULE1,LOCK_RULE2 = CONJ_PAIR LOCK_RULES;;

g `!x y z. LOCK x y /\ z = APPEND y (CONS 2 y) ==> LOCK (CONS 3 x) z`;;
e (MESON_TAC[LOCK_RULE2]);;
let LOCK_RULE2' = top_thm();;

(* ------------------------------------------------------------------------- *)
(* Solution using tactics.                                                   *)
(* ------------------------------------------------------------------------- *)

g `LOCK [3;2;3] [3;2;3]`;;
e (MATCH_MP_TAC LOCK_RULE2');;
e (EXISTS_TAC `[3]`);;
e (REWRITE_TAC[APPEND]);;
e (MATCH_ACCEPT_TAC LOCK_RULE1);;
top_thm();;

MESON
  [LOCK_RULES; APPEND]
  `LOCK [3;2;3] [3;2;3]`;;

METIS
  [LOCK_RULES; APPEND]
  `LOCK [3;2;3] [3;2;3]`;;

(* ------------------------------------------------------------------------- *)
(* Solution using solvers.                                                   *)
(* ------------------------------------------------------------------------- *)

gg `??x. LOCK x x`;;
ee (APPLY_SLV LOCK_RULE1);;
bb();;
ee (APPLY_SLV LOCK_RULE2);;
bb();;
ee (APPLY_SLV LOCK_RULE2');;
tt CONJ_TAC;;
ee (APPLY_SLV LOCK_RULE1);;
ee (APPLY_SLV CONS_EQ_APPEND);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV REFL_APPEND_NIL);;
top_thm1();;

let STEP_SLV : solver =
  COLLECT_SLV
    [TACTIC_SLV CONJ_TAC;
     REFL_SLV;
     ACCEPT_SLV LOCK_RULE1;
     RULE_SLV LOCK_RULE2';
     ACCEPT_SLV REFL_APPEND_NIL;
     RULE_SLV CONS_EQ_APPEND];;

let rec SEARCH_SLV : solver =
  REPEAT_SLV STEP_SLV;;

gg `??x. LOCK x x`;;
ee SEARCH_SLV;;
let sols = top_thms();;

(* Alternative method. *)
let rec SEARCH_ALT_SLV : solver =
  fun g -> CONCAT_SLV (TACTIC_SLV ALL_TAC)
                      (THEN_SLV STEP_SLV SEARCH_SLV) g;;

let default : 'a option -> 'a =
  function
      Some x -> x
    | None -> failwith "default";;

gg `??x. LOCK x x`;;
ee SEARCH_ALT_SLV;;
let sols_alt = stream_mapfilter default (top_thms ());;
(* [3;2;3] Ã¨ l'unico punto fisso, se cerchiamo altre soluzioni diverge.
   drop 1 sols;;
*)


(* ------------------------------------------------------------------------- *)
(* Second example.                                                           *)
(*                                                                           *)
(* M-I:   For any number X,  2X2 produces X.                                 *)
(* M-II:  If X produces Y, then 6X produces 2Y.                              *)
(* M-III: If X produces Y, then 4X produces REVERSE Y.                       *)
(* M-IV:  If X produces Y, then 5X produces YY.                              *)
(* ------------------------------------------------------------------------- *)

let LOCK2_RULES,LOCK2_INDUCT,LOCK2_CASES = new_inductive_definition
  `(!x. LOCK2 (CONS 2 (APPEND x [2])) x) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 6 x) (CONS 2 y)) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 4 x) (REVERSE y)) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 5 x) (APPEND y y))`;;

let [L1;L2;L3;L4] = CONJUNCTS LOCK2_RULES;;

let L1' = prove
 (`!x y. x = APPEND y [2] ==> LOCK2 (CONS 2 x) y`,
  MESON_TAC[L1]);;

let L3' = prove
 (`!x y z. z = REVERSE y /\ LOCK2 x y ==> LOCK2 (CONS 4 x) z`,
  MESON_TAC[L3]);;

let L4' = prove
 (`!x y z. z = APPEND y y /\ LOCK2 x y ==> LOCK2 (CONS 5 x) z`,
  MESON_TAC[L4]);;

g `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
e (SUBGOAL_THEN `[5;4;6;4;2;5;4;6;4;2] = APPEND [5;4;6;4;2] [5;4;6;4;2]`
     (fun th -> GEN_REWRITE_TAC RAND_CONV [th]));;
e (REWRITE_TAC[APPEND]);;
e (MATCH_MP_TAC L4');;
e (EXISTS_TAC `[5;4;6;4;2]`);;
e CONJ_TAC;;
e REFL_TAC;;
e (GEN_REWRITE_TAC RAND_CONV [GSYM (REWRITE_CONV [REVERSE; APPEND]
     `REVERSE [2;4;6;4;5]`)]);;
e (MATCH_MP_TAC L3);;
e (MATCH_MP_TAC L2);;
e (GEN_REWRITE_TAC RAND_CONV [GSYM (REWRITE_CONV [REVERSE; APPEND]
     `REVERSE [5;4;6;4]`)]);;
e (MATCH_MP_TAC L3);;
e (GEN_REWRITE_TAC LAND_CONV [GSYM (REWRITE_CONV [APPEND]
     `(CONS 2 (APPEND [5;4;6;4] [2]))`)]);;
e (MATCH_ACCEPT_TAC L1);;
top_thm();;

(* ------------------------------------------------------------------------- *)
(* HIC SUNT LEONES!!!                                                        *)
(* ------------------------------------------------------------------------- *)

let LIST_CLAUSES = prove
 (`(!l1 l2:A list. l1 = [] /\ l2 = [] ==> APPEND l1 l2 = []) /\
   (!l1 l2:A list. l1 = [] /\ l2 = [] ==> [] = APPEND l1 l2) /\
   (!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> CONS h t = APPEND l1 l2) /\
   (!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> APPEND l1 l2 = CONS h t) /\
   (!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> APPEND l1 l2 = CONS h t) /\
   (!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> CONS h t = APPEND l1 l2) /\
   (!l1 l2 m1 m2 x:A list. APPEND l1 l2 = x /\ APPEND m1 m2 = x ==> APPEND l1 l2 = APPEND m1 m2)`,
  SIMP_TAC[APPEND]);;

let APPEND_NIL_RULE = prove
 (`[]:A list = APPEND [] []`,
  REWRITE_TAC[APPEND]);;

let APPEND_CONS_RULE = prove
 (`!x:A l l'. l' = APPEND l (CONS x l)
              ==> CONS x l' = APPEND (CONS x l) (CONS x l)`,
  SIMP_TAC[APPEND]);;

let APPEND_CONS_RULE_EQ = prove
 (`!x:A l l'.
    CONS x l' = APPEND (CONS x l) (CONS x l) <=> l' = APPEND l (CONS x l)`,
  REWRITE_TAC[APPEND; CONS_11]);;

let CONS_APPEND_SLV : solver =
  MAP_COLLECT_SLV APPLY_SLV [APPEND_NIL_RULE; APPEND_CONS_RULE];;

let APPEND_APPEND_INTRO_CLAUSE = prove
 (`!l t:A list. l = APPEND t (REVAPPEND [] t) ==> l = APPEND t t`,
  REWRITE_TAC[REVAPPEND_CLAUSES]);;

let APPEND_REVAPPEND_NIL_RULE = prove
 (`[]:A list = APPEND [] (REVAPPEND [] [])`,
  REWRITE_TAC[APPEND; REVAPPEND_CLAUSES]);;

let APPEND_REVAPPEND_CONS_RULE = prove
 (`!x:A p t l. l = APPEND t (REVAPPEND (CONS x p) t)
               ==> CONS x l = APPEND (CONS x t) (REVAPPEND p (CONS x t))`,
  REWRITE_TAC[REVAPPEND_CLAUSES; APPEND; CONS_11]);;

let APPEND_REVAPPEND_CONS_RULE_EQ = prove
 (`!x:A p t l. CONS x l = APPEND (CONS x t) (REVAPPEND p (CONS x t)) <=>
               l = APPEND t (REVAPPEND (CONS x p) t)`,
  REWRITE_TAC[REVAPPEND_CLAUSES; APPEND; CONS_11]);;

let EQ_APPEND_NIL = prove
  (`!l1 l2:A list. l1 = l2 ==> l1 = APPEND [] l2`,
   REWRITE_TAC[APPEND]);;

(* Cut goals of the form ?- F *)
let FALSE_SLV : solver =
  fun (_,(_,w)) as mgl ->
    if w = `F` then Empty else TACTIC_SLV ALL_TAC mgl;;

gg `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
ee (THEN_SLV (APPLY_SLV L4') (TACTIC_SLV CONJ_TAC));;
ee (APPLY_SLV APPEND_APPEND_INTRO_CLAUSE);;

ee (APPLY_SLV APPEND_REVAPPEND_CONS_CLAUSE);;

ee (THEN_SLV (APPLY_SLV EQ_APPEND_NIL)
     (THEN_SLV (TACTIC_SLV (REWRITE_TAC[REVAPPEND_CLAUSES; NOT_CONS_NIL])
               FALSE_SLV)));;



ee CONS_APPEND_SLV;;
ee (APPLY_SLV APPEND_CONS_CLAUSE);;
ee CONS_APPEND_SLV;;
ss();;

let LIST_EQ_APPEND_SLV : solver =
  REPEAT_SLV
    (COLLECT_SLV
       [REFL_SLV;
        APPLY_SLV REFL_APPEND_NIL;
        APPLY_SLV CONS_EQ_APPEND;
        TACTIC_SLV ALL_TAC]);;

let L4'_SLV : solver =
  THEN_SLV (APPLY_SLV L4')
           (THENL_SLV (TACTIC_SLV CONJ_TAC)
                      [TACTIC_SLV ALL_TAC;
                       LIST_EQ_APPEND_SLV]);;

let CONS_EQ_APPEND_SLV : solver =
  THENL_SLV
     (TACTIC_SLV
        (MATCH_MP_TAC CONS_EQ_APPEND THEN
         META_EXISTS_TAC THEN
         CONJ_TAC))
  [REFL_SLV; TACTIC_SLV ALL_TAC];;

let LIST_LEMMAS = CONJUNCTS LIST_CLAUSES;;

(* TODO: Serve? *)
let REVERSE_CLAUSES_ALT = prove
 (`(!l:A list. l = [] ==> l = REVERSE []) /\
  (!h:A t l s. APPEND s [h] = l /\ s = REVERSE t ==> l = REVERSE (CONS h t))`,
  CONJ_TAC THENL
  [MESON_TAC[REVERSE_EQ_EMPTY];
   REWRITE_TAC[REVERSE] THEN MESON_TAC[]]);;

let REVERSE_CLAUSES = prove
 (`(!l:A list. l = [] ==> [] = REVERSE l) /\
   (!l h:A t s. l = APPEND s [h] /\ t = REVERSE s ==> CONS h t = REVERSE l)`,
  CONJ_TAC THENL
  [MESON_TAC[REVERSE_EQ_EMPTY]; ALL_TAC] THEN
  LIST_INDUCT_TAC THENL
  [MESON_TAC[APPEND_EQ_NIL; NOT_CONS_NIL]; ALL_TAC] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[REVERSE] THEN
  POP_ASSUM MP_TAC THEN
  STRUCT_CASES_TAC (ISPEC `t:A list` list_CASES) THEN
  STRUCT_CASES_TAC (ISPEC `s:A list` list_CASES) THEN
  REWRITE_TAC[REVERSE; APPEND; CONS_11] THEN
  MESON_TAC[APPEND_EQ_NIL; NOT_CONS_NIL; APPEND]);;

let REVERSE_LEMMAS = CONJUNCTS REVERSE_CLAUSES;;


let LIST_SIMPL_SLV : solver =
  THEN_SLV (TACTIC_SLV
             (REWRITE_TAC[APPEND; REVERSE;
                          APPEND_EQ_NIL; REVERSE_EQ_EMPTY;
                          CONS_11; NOT_CONS_NIL]))
           (THEN_SLV FALSE_SLV
                     (TACTIC_SLV (REPEAT CONJ_TAC)));;

let LIST_EQ_STEP_SLV : solver =
  THEN_SLV LIST_SIMPL_SLV
    (COLLECT_SLV
      [REFL_SLV;
       TACTIC_SLV CONJ_TAC;
       MAP_COLLECT_SLV APPLY_SLV (LIST_LEMMAS @ REVERSE_LEMMAS)]);;

let LIST_EQ_APPEND_SLV : solver =
  THEN_SLV (REPEAT_SLV LIST_EQ_STEP_SLV)
           LIST_SIMPL_SLV;;

(* Example. *)
gg `??l. [1;2;3] = REVERSE l`;;
ee LIST_EQ_APPEND_SLV;;
top_thms();;

let LOCK2_SLV : solver = MAP_COLLECT_SLV APPLY_SLV [L1; L2; L3'; L4'];;

let L1_SLV : solver = THEN_SLV (APPLY_SLV L1') LIST_EQ_APPEND_SLV;;
let L2_SLV : solver = APPLY_SLV L2;;
let L3_SLV : solver =
  THEN_SLV (APPLY_SLV L3')
    (THENL_SLV (TACTIC_SLV CONJ_TAC)
       [LIST_EQ_APPEND_SLV; TACTIC_SLV ALL_TAC]);;
let L4_SLV : solver =
  THEN_SLV (APPLY_SLV L4')
    (THENL_SLV (TACTIC_SLV CONJ_TAC)
      [LIST_EQ_APPEND_SLV; TACTIC_SLV ALL_TAC]);;

let CONS_EQ_APPEND_NIL = prove
 (`!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> CONS h t = APPEND l1 l2`,
  MESON_TAC[APPEND]);;

let CONS_EQ_APPEND_CONS = prove
(`!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> CONS h t = APPEND l1 l2`,
  MESON_TAC[APPEND]);;

gg `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
ee (APPLY_SLV L4');;
tt CONJ_TAC;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_NIL);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee REFL_SLV;;
ee (APPLY_SLV L3');;
tt CONJ_TAC;;
ee LIST_EQ_APPEND_SLV;;
tt (REWRITE_TAC[APPEND]);;
ee (APPLY_SLV L2);;
ee (APPLY_SLV L3');;
tt CONJ_TAC;;
ee LIST_EQ_APPEND_SLV;;
tt (REWRITE_TAC[APPEND]);;
ee (APPLY_SLV L1');;
tt (REWRITE_TAC[APPEND]);;
let Cons (Some (_, th), _) = top_thms();;

(*
time MESON
  [LOCK2_RULES; REVERSE; APPEND; REFL_APPEND_NIL; CONS_EQ_APPEND]
  `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;

time METIS
  [LOCK2_RULES; REVERSE; APPEND; REFL_APPEND_NIL; CONS_EQ_APPEND]
  `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
*)

gg `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
ee (THEN_SLV (APPLY_SLV L4') (TACTIC_SLV CONJ_TAC));;
ee (APPLY_SLV EQ_APPEND_NIL);;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;

tt (TACTIC_SLV CONJ_TAC);;
ee REFL_SLV;;
tt (THEN_SLV (REWRITE_TAC[NOT_CONS_NIL]) FALSE_SLV);;


ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_CONS);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV CONS_EQ_APPEND_NIL);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee REFL_SLV;;
ee (APPLY_SLV L3');;
tt CONJ_TAC;;
ee LIST_EQ_APPEND_SLV;;
tt (REWRITE_TAC[APPEND]);;
ee (APPLY_SLV L2);;
ee (APPLY_SLV L3');;
tt CONJ_TAC;;
ee LIST_EQ_APPEND_SLV;;
tt (REWRITE_TAC[APPEND]);;
ee (APPLY_SLV L1');;
tt (REWRITE_TAC[APPEND]);;
let Cons (Some (_, th), _) = top_thms();;
