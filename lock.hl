(* ========================================================================= *)
(* Semicertified interactive logic programming.                              *)
(*                                                                           *)
(* Copyright (c) 2017-2019 Marco Maggesi, Massimo Nocentini                  *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Examples from The Mystery of the Monte Carlo Lock.                        *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Further solvers.                                                          *)
(* ------------------------------------------------------------------------- *)

(* Cut goals of the form ?- F *)
let FALSE_SLV : solver =
  fun (_,(_,w)) as mgl ->
    if w = `F` then Empty else TACTIC_SLV ALL_TAC mgl;;

(* ------------------------------------------------------------------------- *)
(* Miscellanea on lists.                                                     *)
(* ------------------------------------------------------------------------- *)

g `!l:A list. l = APPEND [] l`;;
e (REWRITE_TAC[APPEND]);;
let REFL_APPEND_NIL = top_thm();;

g `!h:A t t' l1 l2.
     l1 = CONS h t' /\ t = APPEND t' l2 ==> CONS h t = APPEND l1 l2`;;
e (REPEAT STRIP_TAC THEN REPEAT (FIRST_X_ASSUM SUBST_VAR_TAC));;
e (REWRITE_TAC[APPEND]);;
let CONS_EQ_APPEND = top_thm();;

let REVAPPEND = new_definition
  `REVAPPEND p t : A list = APPEND (REVERSE p) t`;;

let REVAPPEND_CLAUSES = prove
 (`(!t:A list. REVAPPEND [] t = t) /\
   (!x:A p t. REVAPPEND (CONS x p) t = REVAPPEND p (CONS x t))`,
  REWRITE_TAC[REVAPPEND; REVERSE; APPEND; GSYM APPEND_ASSOC]);;

let REVERSE_EQ_REVAPPEND = prove
 (`!l:A list. REVERSE l = REVAPPEND l []`,
  REWRITE_TAC[REVAPPEND; APPEND_NIL]);;

(* ------------------------------------------------------------------------- *)
(* First example.                                                            *)
(* ------------------------------------------------------------------------- *)

let LOCK_RULES,LOCK_INDUCT,LOCK_CASES = new_inductive_definition
  `(!x. LOCK (CONS 2 x) x) /\
   (!x y. LOCK x y ==> LOCK (CONS 3 x) (APPEND y (CONS 2 y)))`;;

let LOCK_RULE1,LOCK_RULE2 = CONJ_PAIR LOCK_RULES;;

g `!x y z. LOCK x y /\ z = APPEND y (CONS 2 y) ==> LOCK (CONS 3 x) z`;;
e (MESON_TAC[LOCK_RULE2]);;
let LOCK_RULE2' = top_thm();;

(* ------------------------------------------------------------------------- *)
(* Solution using tactics.                                                   *)
(* ------------------------------------------------------------------------- *)

g `LOCK [3;2;3] [3;2;3]`;;
e (MATCH_MP_TAC LOCK_RULE2');;
e (EXISTS_TAC `[3]`);;
e (REWRITE_TAC[APPEND]);;
e (MATCH_ACCEPT_TAC LOCK_RULE1);;
top_thm();;

MESON
  [LOCK_RULES; APPEND]
  `LOCK [3;2;3] [3;2;3]`;;

METIS
  [LOCK_RULES; APPEND]
  `LOCK [3;2;3] [3;2;3]`;;

(* ------------------------------------------------------------------------- *)
(* Solution using solvers.                                                   *)
(* ------------------------------------------------------------------------- *)

gg `??x. LOCK x x`;;
ee (APPLY_SLV LOCK_RULE1);;
bb();;
ee (APPLY_SLV LOCK_RULE2);;
bb();;
ee (APPLY_SLV LOCK_RULE2');;
tt CONJ_TAC;;
ee (APPLY_SLV LOCK_RULE1);;
ee (APPLY_SLV CONS_EQ_APPEND);;
tt CONJ_TAC;;
ee REFL_SLV;;
ee (APPLY_SLV REFL_APPEND_NIL);;
top_thm1();;

let STEP_SLV : solver =
  COLLECT_SLV
    [TACTIC_SLV CONJ_TAC;
     REFL_SLV;
     ACCEPT_SLV LOCK_RULE1;
     RULE_SLV LOCK_RULE2';
     ACCEPT_SLV REFL_APPEND_NIL;
     RULE_SLV CONS_EQ_APPEND];;

let rec SEARCH_SLV : solver =
  REPEAT_SLV STEP_SLV;;

gg `??x. LOCK x x`;;
ee SEARCH_SLV;;
let sols = top_thms();;

(* Alternative method. *)
let rec SEARCH_ALT_SLV : solver =
  fun g -> CONCAT_SLV (TACTIC_SLV ALL_TAC)
                      (THEN_SLV STEP_SLV SEARCH_SLV) g;;

let default : 'a option -> 'a =
  function
      Some x -> x
    | None -> failwith "default";;

gg `??x. LOCK x x`;;
ee SEARCH_ALT_SLV;;
let sols_alt = stream_mapfilter default (top_thms ());;
(* [3;2;3] Ã¨ l'unico punto fisso, se cerchiamo altre soluzioni diverge.
   drop 1 sols;;
*)


(* ------------------------------------------------------------------------- *)
(* Second example.                                                           *)
(*                                                                           *)
(* M-I:   For any number X,  2X2 produces X.                                 *)
(* M-II:  If X produces Y, then 6X produces 2Y.                              *)
(* M-III: If X produces Y, then 4X produces REVERSE Y.                       *)
(* M-IV:  If X produces Y, then 5X produces YY.                              *)
(* ------------------------------------------------------------------------- *)

let LOCK2_RULES,LOCK2_INDUCT,LOCK2_CASES = new_inductive_definition
  `(!x. LOCK2 (CONS 2 (APPEND x [2])) x) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 6 x) (CONS 2 y)) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 4 x) (REVERSE y)) /\
   (!x y. LOCK2 x y ==> LOCK2 (CONS 5 x) (APPEND y y))`;;

let [L1;L2;L3;L4] = CONJUNCTS LOCK2_RULES;;

let L1' = prove
 (`!x y. x = APPEND y [2] ==> LOCK2 (CONS 2 x) y`,
  MESON_TAC[L1]);;

let L3' = prove
 (`!x y z. z = REVERSE y /\ LOCK2 x y ==> LOCK2 (CONS 4 x) z`,
  MESON_TAC[L3]);;

let L4' = prove
 (`!x y z. z = APPEND y y /\ LOCK2 x y ==> LOCK2 (CONS 5 x) z`,
  MESON_TAC[L4]);;

g `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
e (SUBGOAL_THEN `[5;4;6;4;2;5;4;6;4;2] = APPEND [5;4;6;4;2] [5;4;6;4;2]`
     (fun th -> GEN_REWRITE_TAC RAND_CONV [th]));;
e (REWRITE_TAC[APPEND]);;
e (MATCH_MP_TAC L4');;
e (EXISTS_TAC `[5;4;6;4;2]`);;
e CONJ_TAC;;
e REFL_TAC;;
e (GEN_REWRITE_TAC RAND_CONV [GSYM (REWRITE_CONV [REVERSE; APPEND]
     `REVERSE [2;4;6;4;5]`)]);;
e (MATCH_MP_TAC L3);;
e (MATCH_MP_TAC L2);;
e (GEN_REWRITE_TAC RAND_CONV [GSYM (REWRITE_CONV [REVERSE; APPEND]
     `REVERSE [5;4;6;4]`)]);;
e (MATCH_MP_TAC L3);;
e (GEN_REWRITE_TAC LAND_CONV [GSYM (REWRITE_CONV [APPEND]
     `(CONS 2 (APPEND [5;4;6;4] [2]))`)]);;
e (MATCH_ACCEPT_TAC L1);;
top_thm();;

(* ------------------------------------------------------------------------- *)
(* HIC SUNT LEONES!!!                                                        *)
(* ------------------------------------------------------------------------- *)

let LIST_CLAUSES = prove
 (`(!l1 l2:A list. l1 = [] /\ l2 = [] ==> APPEND l1 l2 = []) /\
   (!l1 l2:A list. l1 = [] /\ l2 = [] ==> [] = APPEND l1 l2) /\
   (!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> CONS h t = APPEND l1 l2) /\
   (!h:A t l1 l2. l1 = [] /\ CONS h t = l2 ==> APPEND l1 l2 = CONS h t) /\
   (!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> APPEND l1 l2 = CONS h t) /\
   (!h:A t l1 l2 s. l1 = CONS h s /\ t = APPEND s l2 ==> CONS h t = APPEND l1 l2) /\
   (!l1 l2 m1 m2 x:A list. APPEND l1 l2 = x /\ APPEND m1 m2 = x ==> APPEND l1 l2 = APPEND m1 m2)`,
  SIMP_TAC[APPEND]);;

let APPEND_NIL_RULE = prove
 (`[]:A list = APPEND [] []`,
  REWRITE_TAC[APPEND]);;

let APPEND_CONS_RULE = prove
 (`!x:A l l'. l' = APPEND l (CONS x l)
              ==> CONS x l' = APPEND (CONS x l) (CONS x l)`,
  SIMP_TAC[APPEND]);;

let APPEND_CONS_RULE_EQ = prove
 (`!x:A l l'.
    CONS x l' = APPEND (CONS x l) (CONS x l) <=> l' = APPEND l (CONS x l)`,
  REWRITE_TAC[APPEND; CONS_11]);;

let CONS_APPEND_SLV : solver =
  MAP_COLLECT_SLV APPLY_SLV [APPEND_NIL_RULE; APPEND_CONS_RULE];;

let APPEND_APPEND_INTRO_CLAUSE = prove
 (`!l t:A list. l = APPEND t (REVAPPEND [] t) ==> l = APPEND t t`,
  REWRITE_TAC[REVAPPEND_CLAUSES]);;

let APPEND_REVAPPEND_NIL_RULE = prove
 (`[]:A list = APPEND [] (REVAPPEND [] [])`,
  REWRITE_TAC[APPEND; REVAPPEND_CLAUSES]);;

let APPEND_REVAPPEND_CONS_RULE = prove
 (`!x:A p t l. l = APPEND t (REVAPPEND (CONS x p) t)
               ==> CONS x l = APPEND (CONS x t) (REVAPPEND p (CONS x t))`,
  REWRITE_TAC[REVAPPEND_CLAUSES; APPEND; CONS_11]);;

let APPEND_REVAPPEND_CONS_RULE_EQ = prove
 (`!x:A p t l. CONS x l = APPEND (CONS x t) (REVAPPEND p (CONS x t)) <=>
               l = APPEND t (REVAPPEND (CONS x p) t)`,
  REWRITE_TAC[REVAPPEND_CLAUSES; APPEND; CONS_11]);;

let EQ_APPEND_NIL = prove
  (`!l1 l2:A list. l1 = l2 ==> l1 = APPEND [] l2`,
   REWRITE_TAC[APPEND]);;

let REVERSE_UNIQUE = prove
 (`!l l':A list. REVERSE l =  l' ==> l = REVERSE l'`,
  MESON_TAC[REVERSE_REVERSE]);;

let FOO_SLV : solver =
  (REPEAT_SLV
    (CONCAT_SLV
      (THEN_SLV
        (APPLY_SLV EQ_APPEND_NIL)
        (THEN_SLV
          (TACTIC_SLV (REWRITE_TAC[REVAPPEND_CLAUSES; NOT_CONS_NIL; CONS_11]))
          FALSE_SLV))
      (APPLY_SLV APPEND_REVAPPEND_CONS_RULE)));;

let L1_SLV : solver =
  THEN_SLV (APPLY_SLV L1')
    (TACTIC_SLV (REWRITE_TAC[APPEND]));;

let L2_SLV : solver = APPLY_SLV L2;;

let L3_SLV : solver =
  THEN_SLV (APPLY_SLV L3')
    (THENL_SLV (TACTIC_SLV CONJ_TAC)
      [THEN_SLV (APPLY_SLV REVERSE_UNIQUE)
        (THEN_SLV (TACTIC_SLV (REWRITE_TAC[REVERSE; APPEND]))
          REFL_SLV)
      ;
      TACTIC_SLV ALL_TAC]);;

let L4_SLV : solver =
  THEN_SLV (APPLY_SLV L4')
    (THENL_SLV (TACTIC_SLV CONJ_TAC)
      [THEN_SLV
        (APPLY_SLV APPEND_APPEND_INTRO_CLAUSE)
        FOO_SLV
      ;
      TACTIC_SLV ALL_TAC]);;

let LOCK2_STEP_SLV : solver =
  COLLECT_SLV [L1_SLV; L2_SLV; L3_SLV; L4_SLV];;

gg `LOCK2 [5;4;6;4;2;5;4;6;4;2] [5;4;6;4;2;5;4;6;4;2]`;;
ee (REPEAT_SLV LOCK2_STEP_SLV);;
top_thms();;
