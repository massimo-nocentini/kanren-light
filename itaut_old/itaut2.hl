(* ========================================================================= *)
(* Intuitionistic theorem prover (complete for propositional fragment).      *)
(*                                                                           *)
(*       John Harrison, University of Cambridge Computer Laboratory          *)
(*                                                                           *)
(*            (c) Copyright, University of Cambridge 1998                    *)
(*              (c) Copyright, John Harrison 1998-2007                       *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* ITAUT solver.                                                             *)
(* ------------------------------------------------------------------------- *)

  let CONJUNCTS_THEN' ttac cth =
    ttac(CONJUNCT1 cth) THEN ttac(CONJUNCT2 cth);;

  let IMPLICATE t =
    let th1 = AP_THM NOT_DEF (dest_neg t) in
    CONV_RULE (RAND_CONV BETA_CONV) th1;;

  let RIGHT_REVERSIBLE_TAC = FIRST
   [CONJ_TAC;                                                     (* and     *)
    GEN_TAC;                                                      (* forall  *)
    DISCH_TAC;                                                    (* implies *)
    (fun gl -> CONV_TAC(K(IMPLICATE(snd gl))) gl);                (* not     *)
    EQ_TAC]                                                       (* iff     *)
    ;;

  let LEFT_REVERSIBLE_TAC th gl = tryfind (fun ttac -> ttac th gl)
   [CONJUNCTS_THEN' ASSUME_TAC;                                   (* and    *)
    DISJ_CASES_TAC;                                               (* or     *)
    CHOOSE_TAC;                                                   (* exists *)
    (fun th -> ASSUME_TAC (EQ_MP (IMPLICATE (concl th)) th));     (* not    *)
    (CONJUNCTS_THEN' MP_TAC o uncurry CONJ o EQ_IMP_RULE)]        (* iff    *)
    ;;

let META_SPEC_SLV : thm_solver =
  fun th ->
    try let gv = genvar(type_of(fst(dest_forall(concl th)))) in
        TACTIC_SLV (META_SPEC_TAC gv th)
    with Failure _ -> NO_SLV;;

let ANTS_SLV : thm_solver =
  fun th ->
    SOLVER (fun _ ->
      SUBGOAL_THEN (fst(dest_imp(concl th)))
                   (fun ath -> ASSUME_TAC (MP th ath)));;

let META_EXISTS_SLV : solver =
  SOLVER (fun _ gl ->
    let gv = genvar(type_of(fst(dest_exists(snd gl)))) in
    X_META_EXISTS_TAC gv gl);;

let PHASE1_SLV : solver =
  REPEAT_SLV
    (COLLECT_SLV
     [ACCEPT_SLV TRUTH;
      COLLECT_ASSUM_SLV ACCEPT_SLV;
      COLLECT_ASSUM_SLV (fun th -> TACTIC_SLV (CONTR_TAC th));
      TACTIC_SLV RIGHT_REVERSIBLE_TAC;
      COLLECT_X_ASSUM_SLV (fun th -> TACTIC_SLV (LEFT_REVERSIBLE_TAC th))]);;

let PHASE2_SLV : solver =
  COLLECT_SLV
    [TACTIC_SLV DISJ1_TAC;
     TACTIC_SLV DISJ2_TAC;
     COLLECT_ASSUM_SLV ANTS_SLV;
     COLLECT_ASSUM_SLV META_SPEC_SLV;
     META_EXISTS_SLV];;

let ITAUT_STEP_SLV : solver =
  THEN_SLV PHASE2_SLV PHASE1_SLV;;

let ITAUT_SLV : solver =
  THEN_SLV PHASE1_SLV (LAZY_REPEAT_SLV ITAUT_STEP_SLV);;

let CLEANUP_SLV : solver =
  SOLVER (fun mvs ->
    REPEAT
      (FIRST
         [UNIFY_ACCEPT_TAC mvs TRUTH;
          FIRST_X_ASSUM CONTR_TAC;
          RIGHT_REVERSIBLE_TAC;
          FIRST_X_ASSUM LEFT_REVERSIBLE_TAC]));;

let CLEANUP_ACCEPT_SLV : solver =
  THEN_SLV CLEANUP_SLV
           (COLLECT_SLV [COLLECT_ASSUM_SLV ACCEPT_SLV;
                         TACTIC_SLV ALL_TAC]);;

let PHASE_SLV : solver =
    (COLLECT_SLV
     [TACTIC_SLV DISJ1_TAC;
      TACTIC_SLV DISJ2_TAC;
      COLLECT_X_ASSUM_SLV ANTS_SLV;
      COLLECT_ASSUM_SLV META_SPEC_SLV;
      META_EXISTS_SLV]);;

let ITAUT_REPEAT_SLV : solver =
  THEN_SLV CLEANUP_ACCEPT_SLV
           (LAZY_REPEAT_SLV (THEN_SLV PHASE_SLV CLEANUP_ACCEPT_SLV));;

(* ------------------------------------------------------------------------- *)
(* Alternative interface.                                                    *)
(* ------------------------------------------------------------------------- *)

let ITAUT2 tm = snd(get(solve ITAUT_SLV tm));;
let ITAUT2_REPEAT tm = snd(get(solve ITAUT_REPEAT_SLV tm));;

(* ------------------------------------------------------------------------- *)
(* ITAUT from the HOL Library.  Fails on this example.                       *)
(* ------------------------------------------------------------------------- *)

(*;;
ITAUT
  `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
   padre c d /\
   padre a c /\
   padre a b
   ==> ?x:A. nonno a x`;;
*)

(* ------------------------------------------------------------------------- *)
(* Testing our own version.                                                  *)
(* ------------------------------------------------------------------------- *)

time ITAUT2
  `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
   padre c d /\
   padre a c /\
   padre a b
   ==> ?x:A. nonno a x`;;

time ITAUT2_REPEAT
  `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
   padre c d /\
   padre a c /\
   padre a b
   ==> ?x:A. nonno a x`;;

time TAUT
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F))
  ==> (output <=> ~(input_a \/ input_b))`;;

time ITAUT2_REPEAT
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F))
  ==> (output <=> ~(input_a \/ input_b))`;;

gg
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F))
  ==> (output <=> ~(input_a \/ input_b))`;;
ee ITAUT_REPEAT_SLV;;
ss ();;



(* time TAUT 0.7 *)

time ITAUT2_REPEAT
`(i1 /\ i2 <=> a) /\
 (i1 /\ i3 <=> b) /\
 (i2 /\ i3 <=> c) /\
 (i1 /\ c <=> d) /\
 (m /\ r <=> e) /\
 (m /\ w <=> f) /\
 (n /\ w <=> g) /\
 (p /\ w <=> h) /\
 (q /\ w <=> i) /\
 (s /\ x <=> j) /\
 (t /\ x <=> k) /\
 (v /\ x <=> l) /\
 (i1 \/ i2 <=> m) /\
 (i1 \/ i3 <=> n) /\
 (i1 \/ q <=> p) /\
 (i2 \/ i3 <=> q) /\
 (i3 \/ a <=> r) /\
 (a \/ w <=> s) /\
 (b \/ w <=> t) /\
 (d \/ h <=> u) /\
 (c \/ w <=> v) /\
 (~e <=> w) /\
 (~u <=> x) /\
 (i \/ l <=> o1) /\
 (g \/ k <=> o2) /\
 (f \/ j <=> o3)
 ==> (o1 <=> ~i1) /\ (o2 <=> ~i2) /\ (o3 <=> ~i3)`;;
