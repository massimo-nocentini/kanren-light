(* ========================================================================= *)
(* Intuitionistic theorem prover (complete for propositional fragment).      *)
(*                                                                           *)
(*       John Harrison, University of Cambridge Computer Laboratory          *)
(*                                                                           *)
(*            (c) Copyright, University of Cambridge 1998                    *)
(*              (c) Copyright, John Harrison 1998-2007                       *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* ITAUT solver.                                                             *)
(* ------------------------------------------------------------------------- *)

  let CONJUNCTS_THEN' ttac cth =
    ttac(CONJUNCT1 cth) THEN ttac(CONJUNCT2 cth);;

  let IMPLICATE t =
    let th1 = AP_THM NOT_DEF (dest_neg t) in
    CONV_RULE (RAND_CONV BETA_CONV) th1;;

  let RIGHT_REVERSIBLE_TAC = FIRST
   [CONJ_TAC;                                                     (* and     *)
    GEN_TAC;                                                      (* forall  *)
    DISCH_TAC;                                                    (* implies *)
    (fun gl -> CONV_TAC(K(IMPLICATE(snd gl))) gl);                (* not     *)
    EQ_TAC]                                                       (* iff     *)
    ;;

  let LEFT_REVERSIBLE_TAC th gl = tryfind (fun ttac -> ttac th gl)
   [CONJUNCTS_THEN' ASSUME_TAC;                                   (* and    *)
    DISJ_CASES_TAC;                                               (* or     *)
    CHOOSE_TAC;                                                   (* exists *)
    (fun th -> ASSUME_TAC (EQ_MP (IMPLICATE (concl th)) th));     (* not    *)
    (CONJUNCTS_THEN' MP_TAC o uncurry CONJ o EQ_IMP_RULE)]        (* iff    *)
    ;;

(*
  let rec ITAUT_TAC mvs n gl =
    if n <= 0 then failwith "ITAUT_TAC: Too deep" else
    ((FIRST_ASSUM (UNIFY_ACCEPT_TAC mvs)) ORELSE
     (ACCEPT_TAC TRUTH) ORELSE
     (FIRST_ASSUM CONTR_TAC) ORELSE
     (RIGHT_REVERSIBLE_TAC THEN TRY (ITAUT_TAC mvs n)) ORELSE
     (FIRST_X_ASSUM LEFT_REVERSIBLE_TAC THEN TRY(ITAUT_TAC mvs n)) ORELSE
     (FIRST_X_ASSUM(fun th -> ASSUME_TAC th THEN
       (let gv = genvar(type_of(fst(dest_forall(concl th)))) in
        META_SPEC_TAC gv th THEN
        ITAUT_TAC (gv::mvs) (n - 2) THEN NO_TAC))) ORELSE
     (DISJ1_TAC THEN ITAUT_TAC mvs n THEN NO_TAC) ORELSE
     (DISJ2_TAC THEN ITAUT_TAC mvs n THEN NO_TAC) ORELSE
     (fun gl -> let gv = genvar(type_of(fst(dest_exists(snd gl)))) in
                (X_META_EXISTS_TAC gv THEN
                 ITAUT_TAC (gv::mvs) (n - 2) THEN NO_TAC) gl) ORELSE
     (FIRST_ASSUM(fun th -> SUBGOAL_THEN (fst(dest_imp(concl th)))
                                      (fun ath -> ASSUME_TAC (MP th ath)) THEN
                           ITAUT_TAC mvs (n - 1) THEN NO_TAC))) gl;;
*)

let ITAUT_STEP_SLV : solver =
  THEN_SLV
    (SOLVER (fun mvs gl ->
       REPEAT (FIRST [FIRST_ASSUM (UNIFY_ACCEPT_TAC mvs);
                      ACCEPT_TAC TRUTH;
                      FIRST_ASSUM CONTR_TAC;
                      RIGHT_REVERSIBLE_TAC;
                      FIRST_X_ASSUM LEFT_REVERSIBLE_TAC])
              gl))
    (INTERLEAVE_SLV
       [COLLECT_ASSUM_SLV
         (fun th ->
            try let gv = genvar(type_of(fst(dest_forall(concl th)))) in
               TACTIC_SLV (META_SPEC_TAC gv th)
            with Failure _ -> NO_SLV);
        TACTIC_SLV DISJ1_TAC;
        TACTIC_SLV DISJ2_TAC;
        COLLECT_ASSUM_SLV
          (fun th ->
             SOLVER (fun _ gl ->
               SUBGOAL_THEN (fst(dest_imp(concl th)))
                 (fun ath -> ASSUME_TAC (MP th ath))
                 gl));
        SOLVER (fun _ gl ->
          let gv = genvar(type_of(fst(dest_exists(snd gl)))) in
          X_META_EXISTS_TAC gv gl)]);;

let ITAUT_SLV : solver = REPEAT_SLV ITAUT_STEP_SLV;;


(*
let ITAUT_TAC =
  let rec ITAUT_ITERDEEP_TAC n gl =
    remark ("Searching with limit "^(string_of_int n));
    ((ITAUT_TAC [] n THEN NO_TAC) ORELSE ITAUT_ITERDEEP_TAC (n + 1)) gl in
  ITAUT_ITERDEEP_TAC 0;;
*)

(* ------------------------------------------------------------------------- *)
(* Alternative interface.                                                    *)
(* ------------------------------------------------------------------------- *)

(*
let ITAUT tm = prove(tm,ITAUT_TAC);;
*)

let ITAUT2 tm = get(solve ITAUT_SLV tm);;





ITAUT `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
       padre c d /\
       padre a c /\
       padre a b
       ==> ?x:A. nonno a x`;;

gg `??x:A. (!x y z. padre x y /\ padre y z ==> nonno x z) &&
           padre c d &&
           padre a c &&
           padre a b
           ?- nonno a x`;;
ee ITAUT_SLV;;
top_thm1();;

ee (RULE_SLV (ASSUME `!x y z. padre x y /\ padre y z ==> nonno x z`));;
tt CONJ_TAC;;
ee (ACCEPT_SLV (ASSUME `padre (a:A) (c:A) : bool`));;
ee (ACCEPT_SLV (ASSUME `padre (c:A) (d:A) : bool`));;
top_thm1();;

gg `??x:A. (!x y z. padre x y /\ padre y z ==> nonno x z) &&
           padre c d &&
           padre a c &&
           padre a b
           ?- nonno a x`;;
ee (POP_ASSUM_LIST_SLV (PROLOG_SLV NO_CONV));;
top_thm1();;
*)
