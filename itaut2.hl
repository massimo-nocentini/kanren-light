(* ========================================================================= *)
(* Intuitionistic theorem prover (complete for propositional fragment).      *)
(*                                                                           *)
(*       John Harrison, University of Cambridge Computer Laboratory          *)
(*                                                                           *)
(*            (c) Copyright, University of Cambridge 1998                    *)
(*              (c) Copyright, John Harrison 1998-2007                       *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* ITAUT solver.                                                             *)
(* ------------------------------------------------------------------------- *)

  let CONJUNCTS_THEN' ttac cth =
    ttac(CONJUNCT1 cth) THEN ttac(CONJUNCT2 cth);;

  let IMPLICATE t =
    let th1 = AP_THM NOT_DEF (dest_neg t) in
    CONV_RULE (RAND_CONV BETA_CONV) th1;;

  let RIGHT_REVERSIBLE_TAC = FIRST
   [CONJ_TAC;                                                     (* and     *)
    GEN_TAC;                                                      (* forall  *)
    DISCH_TAC;                                                    (* implies *)
    (fun gl -> CONV_TAC(K(IMPLICATE(snd gl))) gl);                (* not     *)
    EQ_TAC]                                                       (* iff     *)
    ;;

  let LEFT_REVERSIBLE_TAC th gl = tryfind (fun ttac -> ttac th gl)
   [CONJUNCTS_THEN' ASSUME_TAC;                                   (* and    *)
    DISJ_CASES_TAC;                                               (* or     *)
    CHOOSE_TAC;                                                   (* exists *)
    (fun th -> ASSUME_TAC (EQ_MP (IMPLICATE (concl th)) th));     (* not    *)
    (CONJUNCTS_THEN' MP_TAC o uncurry CONJ o EQ_IMP_RULE)]        (* iff    *)
    ;;

(*
  let rec ITAUT_TAC mvs n gl =
    if n <= 0 then failwith "ITAUT_TAC: Too deep" else
    ((FIRST_ASSUM (UNIFY_ACCEPT_TAC mvs)) ORELSE
     (ACCEPT_TAC TRUTH) ORELSE
     (FIRST_ASSUM CONTR_TAC) ORELSE
     (RIGHT_REVERSIBLE_TAC THEN TRY (ITAUT_TAC mvs n)) ORELSE
     (FIRST_X_ASSUM LEFT_REVERSIBLE_TAC THEN TRY(ITAUT_TAC mvs n)) ORELSE
     (FIRST_X_ASSUM(fun th -> ASSUME_TAC th THEN
       (let gv = genvar(type_of(fst(dest_forall(concl th)))) in
        META_SPEC_TAC gv th THEN
        ITAUT_TAC (gv::mvs) (n - 2) THEN NO_TAC))) ORELSE
     (DISJ1_TAC THEN ITAUT_TAC mvs n THEN NO_TAC) ORELSE
     (DISJ2_TAC THEN ITAUT_TAC mvs n THEN NO_TAC) ORELSE
     (fun gl -> let gv = genvar(type_of(fst(dest_exists(snd gl)))) in
                (X_META_EXISTS_TAC gv THEN
                 ITAUT_TAC (gv::mvs) (n - 2) THEN NO_TAC) gl) ORELSE
     (FIRST_ASSUM(fun th -> SUBGOAL_THEN (fst(dest_imp(concl th)))
                                      (fun ath -> ASSUME_TAC (MP th ath)) THEN
                           ITAUT_TAC mvs (n - 1) THEN NO_TAC))) gl;;
*)

let META_SPEC_SLV : thm_solver =
  fun th ->
    try let gv = genvar(type_of(fst(dest_forall(concl th)))) in
        TACTIC_SLV (META_SPEC_TAC gv th)
    with Failure _ -> NO_SLV;;

let ANTS_SLV : thm_solver =
  fun th ->
    SOLVER (fun _ ->
      SUBGOAL_THEN (fst(dest_imp(concl th)))
                   (fun ath -> ASSUME_TAC (MP th ath)));;

let META_EXISTS_SLV : solver =
  SOLVER (fun _ gl ->
    let gv = genvar(type_of(fst(dest_exists(snd gl)))) in
    X_META_EXISTS_TAC gv gl);;

let PHASE1_SLV : solver =
  SOLVER (fun mvs gl ->
    REPEAT (FIRST [FIRST_ASSUM (UNIFY_ACCEPT_TAC mvs);
                   ACCEPT_TAC TRUTH;
                   FIRST_ASSUM CONTR_TAC;
                   RIGHT_REVERSIBLE_TAC;
                   FIRST_X_ASSUM LEFT_REVERSIBLE_TAC])
           gl);;

let PHASE2_SLV : solver =
  INTERLEAVE_SLV
    [TACTIC_SLV DISJ1_TAC;
     TACTIC_SLV DISJ2_TAC;
     COLLECT_ASSUM_SLV ANTS_SLV;
     COLLECT_ASSUM_SLV META_SPEC_SLV;
     META_EXISTS_SLV];;

let ITAUT_STEP_SLV : solver =
  THEN_SLV PHASE1_SLV PHASE2_SLV;;

let ITAUT_SLV : solver = REPEAT_SLV ITAUT_STEP_SLV;;

(*
let ITAUT_TAC =
  let rec ITAUT_ITERDEEP_TAC n gl =
    remark ("Searching with limit "^(string_of_int n));
    ((ITAUT_TAC [] n THEN NO_TAC) ORELSE ITAUT_ITERDEEP_TAC (n + 1)) gl in
  ITAUT_ITERDEEP_TAC 0;;
*)

(* ------------------------------------------------------------------------- *)
(* Alternative interface.                                                    *)
(* ------------------------------------------------------------------------- *)

let ITAUT2 tm = get(solve ITAUT_SLV tm);;

(* ------------------------------------------------------------------------- *)
(* ITAUT from the HOL Library.  Fails on this example.                       *)
(* ------------------------------------------------------------------------- *)

ITAUT
  `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
   padre c d /\
   padre a c /\
   padre a b
   ==> ?x:A. nonno a x`;;

(* ------------------------------------------------------------------------- *)
(* Testing our own version.                                                  *)
(* ------------------------------------------------------------------------- *)

ITAUT2
  `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
   padre c d /\
   padre a c /\
   padre a b
   ==> ?x:A. nonno a x`;;

(* ------------------------------------------------------------------------- *)
(* Step-by-step.                                                             *)
(* ------------------------------------------------------------------------- *)

gg `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
    padre c d /\
    padre a c /\
    padre a b
    ==> ?x:A. nonno a x`;;
ee PHASE1_SLV;;
ee PHASE2_SLV;;
ee PHASE2_SLV;;
ee PHASE2_SLV;;
ee PHASE2_SLV;;
ee PHASE1_SLV;;
ee PHASE2_SLV;;

let  STEP_SLV : solver = THEN_SLV PHASE1_SLV PHASE2_SLV;;
let STEP2_SLV : solver = THEN_SLV STEP_SLV STEP_SLV;;
let STEP3_SLV : solver = THEN_SLV STEP_SLV STEP2_SLV;;
let STEP4_SLV : solver = THEN_SLV STEP_SLV STEP3_SLV;;

let SOLVED_SLV : solver -> solver =
  fun slv g ->
    let gstates = slv g in
    bind gstates
         (function _,[],_ as gstate -> Cons (gstate,fun () -> Empty)
                 | _ -> Empty);;

ee (COLLECT_SLV
  [SOLVED_SLV STEP_SLV;
   SOLVED_SLV STEP2_SLV;
   SOLVED_SLV STEP3_SLV;
   STEP4_SLV]);;
ss ();;

let DEEPENING_SLV n : solver