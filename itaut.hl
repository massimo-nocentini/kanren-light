  let IMPLICATE (t:term) : thm =
    let th1 = AP_THM NOT_DEF (dest_neg t) in
    CONV_RULE (RAND_CONV BETA_CONV) th1;;

  let CONJUNCTS_THEN' : thm_tactic -> thm_tactic =
    fun ttac cth ->
      ttac(CONJUNCT1 cth) THEN ttac(CONJUNCT2 cth);;

  let RIGHT_REVERSIBLE_TAC : tactic = FIRST
   [CONJ_TAC;                                                     (* and     *)
    GEN_TAC;                                                      (* forall  *)
    DISCH_TAC;                                                    (* implies *)
    (fun gl -> CONV_TAC(K(IMPLICATE(snd gl))) gl);                (* not     *)
    EQ_TAC];;                                                     (* iff     *)

  let LEFT_REVERSIBLE_TAC : thm_tactic =
   fun th gl -> tryfind (fun ttac -> ttac th gl)
     [CONJUNCTS_THEN' ASSUME_TAC;                                 (* and    *)
      DISJ_CASES_TAC;                                             (* or     *)
      CHOOSE_TAC;                                                 (* exists *)
      (fun th -> ASSUME_TAC (EQ_MP (IMPLICATE (concl th)) th));   (* not    *)
      (CONJUNCTS_THEN' MP_TAC o uncurry CONJ o EQ_IMP_RULE)];;    (* iff    *)

let TRACE_TAC msg : tactic =
  fun gl ->
    report msg;
    ALL_TAC gl;;

(*
let TRACE_TAC msg : tactic = ALL_TAC;;
*)

let TRACE_SLV msg : solver =
  TACTIC_SLV (TRACE_TAC msg);;

let DISJ_SLV (slv1:solver) (slv2:solver) : solver =
  let DO_DISJ_SLV =
    CONCAT_SLV (TACTIC_SLV DISJ1_TAC) (TACTIC_SLV DISJ2_TAC) in
  fun (_,gl) as mgl ->
    if is_disj (snd gl)
    then THEN_SLV DO_DISJ_SLV slv1 mgl
    else slv2 mgl;;

(*
let DISJ_SLV : solver =
  CONCAT_SLV (TACTIC_SLV DISJ1_TAC) (TACTIC_SLV DISJ2_TAC);;
*)

let INTRO_EXISTS_SLV : solver =
  fun (m,(asl,w)) as mgl ->
    try let gv = genvar(type_of(fst(dest_exists w))) in
        TACTIC_SLV (X_META_EXISTS_TAC gv) mgl
    with Failure _ -> Empty;;

let SGOAL_TAC : thm_tactic =
  fun th ->
    SUBGOAL_THEN (fst(dest_imp(concl th)))
      (fun ath ->
         ASSUME_TAC (MP th ath) THEN
         TRACE_TAC ("Subgoal solved:\n" ^
                    string_of_thm ath ^ "\n" ^
                    string_of_thm (MP th ath)));;

let SUBGOAL_SLV (slv1:solver) (slv2:solver) (slv3:solver) : solver =
  fun (mvs,(asl,w)) as mgl ->
    try let tm = tryfind (check is_imp o concl o snd) asl in
      IF_SLV (THENL_SLV (TACTIC_SLV (UNDISCH_THEN tm SGOAL_TAC))
                        [THEN_SLV slv1 NO_SLV; TACTIC_SLV ALL_TAC])
             slv2
             (THEN_SLV (TACTIC_SLV (UNDISCH_THEN tm (K ALL_TAC))) slv3) mgl
      with Failure _ -> Empty;;

let REVERSIBLE_TAC : tactic =
  ACCEPT_TAC TRUTH ORELSE
  FIRST_ASSUM CONTR_TAC ORELSE
  RIGHT_REVERSIBLE_TAC ORELSE
  FIRST_X_ASSUM LEFT_REVERSIBLE_TAC;;

let rec DEPTH_ITAUT_SLV n : solver =
  fun mgl ->
    report ("Depth "^string_of_int n);
    if n <= 0 then NO_SLV mgl else
    (
    print_goal (snd mgl);
    THEN_SLV (TACTIC_SLV (REPEAT REVERSIBLE_TAC))
    (CONCAT_SLV
      (THEN_SLV (TRACE_SLV "ACCEPT")
         (COLLECT_ASSUM_SLV (fun th ->
            (SOLVER (fun mvs -> UNIFY_ACCEPT_TAC mvs th)))))
      (DISJ_SLV (DEPTH_ITAUT_SLV (n - 1))
        (COLLECT_SLV
           [THEN_SLV (TRACE_SLV "META_SPEC")
              (COLLECT_X_ASSUM_SLV
                 (fun th -> 
                   THEN_SLV
                     (TACTIC_SLV
                       (fun g ->
                          (let gv = genvar(type_of(fst(dest_forall(concl th)))) in
                           (ASSUME_TAC th THEN META_SPEC_TAC gv th) g)))
                     (fun g -> DEPTH_ITAUT_SLV (n - 2) g)));
            THEN_SLV (TRACE_SLV "EXISTS")
              (IF_SLV INTRO_EXISTS_SLV (DEPTH_ITAUT_SLV (n - 2))
                (THEN_SLV (TRACE_SLV "SUBGOAL")
                  (SUBGOAL_SLV (DEPTH_ITAUT_SLV (n - 1))
                               (DEPTH_ITAUT_SLV (n - 1))
                               (DEPTH_ITAUT_SLV (n - 1)))))]))) mgl
    );;


let ITAUT_SLV =
  let rec ITAUT_ITERDEEP_SLV n gl =
    remark ("Searching with limit "^(string_of_int n));
    CONCAT_SLV (DEPTH_ITAUT_SLV n) (ITAUT_ITERDEEP_SLV (n + 1)) gl in
  ITAUT_ITERDEEP_SLV 0;;

let gstate::_ = take 2 (DEPTH_ITAUT_SLV 4 ([],([],`a ==> ~ ~a`)));;
wrapup gstate;;

(* Diverge perche' non fa backtrack. *)
(*
ITAUT
    `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
     padre A D /\
     padre D E
     ==> ?X. nonno X E`;;
*)

(wrapup o get o DEPTH_ITAUT_SLV 6)
  ([],([],`(!x y. p x /\ q y ==> q x) /\ p a /\ q b ==> q a`));;

(wrapup o get o DEPTH_ITAUT_SLV 10)
  ([],([],
    `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
     padre A B /\ padre B C /\
     padre A D /\ padre D E
     ==> ?X. nonno X E`));;

(wrapup o get o DEPTH_ITAUT_SLV 10)
  ([],([],
    `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
     padre A D /\ padre D E /\
     padre A B /\ padre B C
     ==> ?X. nonno X E`));;

(* ------------------------------------------------------------------------- *)
(* Altri tests in itaut_old/itaut.hl                                         *)
(* ------------------------------------------------------------------------- *)

let gstate = time (get o DEPTH_ITAUT_SLV 9)
 ([],([],
  `(input_a \/ input_b ==> F) /\
   (~input_a ==> internal) /\
   (~input_b ==> (output <=> internal)) /\
   (input_a ==> (output <=> F)) /\
   (input_b ==> (output <=> F))
   ==> output`));;


let gstate = time (get o DEPTH_ITAUT_SLV 10)
([],([],
 `(~input_a ==> internal) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F))
  ==> (output <=> ~(input_a \/ input_b))`));;
wrapup gstate;;
