(* ========================================================================= *)
(* Semicertified interactive logic programming.                              *)
(* ========================================================================= *)

needs "streams.hl";;

type mgoal = term list * goal;;

type solver = mgoal -> goalstate stream;;

type thm_solver = thm -> solver;;

(* ------------------------------------------------------------------------- *)
(* Meta goals.                                                               *)
(* ------------------------------------------------------------------------- *)

parse_as_binder "??";;
parse_as_infix ("?-",(0,"right"));;
parse_as_infix ("&&",(1,"right"));;

let META = new_definition `(??) = (?):(A->bool)->bool`;;
let ENTAILS = new_definition `(?-) = (==>)`;;
let MAND = new_definition `(&&) = (/\)`;;

let is_meta = is_binder "??";;
let dest_meta = dest_binder "??";;
let strip_meta = splitlist dest_meta;;

let is_mand = is_binary "&&";;
let dest_mand = dest_binary "&&";;
let split_mand = striplist dest_mand;;

let is_entails = is_binary "?-";;
let dest_entails = dest_binary "?-";;

let dest_mgoal (tm:term) : mgoal =
  let mvs,rtm = strip_meta tm in
  let hpl,w = try let btm,htm = dest_entails rtm in
                  rev(split_mand btm),htm
              with Failure _ -> [],rtm in
  let asl = map (fun tm -> "",ASSUME tm) hpl in
  mvs,(asl,w);;

(* ------------------------------------------------------------------------- *)
(* Run a solver.                                                             *)
(* ------------------------------------------------------------------------- *)

let wrapup : goalstate -> (term list * instantiation) * thm  =
  fun metas,gls,just ->
    if gls <> [] then failwith "wrapup: Unsolved goals" else
    let th = just null_inst [] in
    metas,th;;

let solve : solver -> term -> (instantiation * thm) stream =
  let run_solver g slv = stream_mapfilter wrapup (slv g) in
  fun slv tm ->
    let p ((mvs',inst),th) = inst,th in
    stream_map p (run_solver (dest_mgoal tm) slv);;

(* ------------------------------------------------------------------------- *)
(* Common pattern for building "singleton" solvers.                          *)
(* ------------------------------------------------------------------------- *)

let SOLVER (f:term list -> goal -> goalstate) : solver =
  fun mvs,gl -> try singleton (f mvs gl) with Failure _ -> Empty;;

(* ------------------------------------------------------------------------- *)
(* Basic solvers.                                                            *)
(* ------------------------------------------------------------------------- *)

let NO_SLV : solver =
  fun _ -> Empty;;

let REFL_SLV =
  SOLVER (fun mvs (asl,w) ->
    let l,r = dest_eq w in
    let inst = term_ty_unify mvs l r in
    let sth = ALPHA (instantiate inst l) (instantiate inst r) in
    let just i _ = INSTANTIATE_ALL i sth in
    ([],inst),[],just);;

(* ------------------------------------------------------------------------- *)
(* Refresh type variables in a theorem.                                      *)
(* ------------------------------------------------------------------------- *)

let genty =
  let count = ref 0 in
  let genty () =
    let ty = mk_vartype("ty"^string_of_int !count) in
    count := !count + 1;
    ty in
  genty;;

let TYFRESH th =
  let tyl = type_vars_in_term (concl th) in
  let i = map (fun ty -> genty(),ty) tyl in
  INST_TYPE i th;;

let SPEC_FRESH th =
  let th = TYFRESH th in
  let v,th' = SPEC_VAR th in
  let v' = genvar(type_of v) in
  v',INST [v',v] th';;

let SPEC_FRESH_ALL = splitlist SPEC_FRESH;;

let ACCEPT_SLV : thm_solver =
  fun th -> SOLVER (fun mvs (asl,w) ->
    let avs,th' = SPEC_FRESH_ALL th in
    let insts = term_ty_unify (union avs mvs) (concl th') w in
    let sth = INSTANTIATE_ALL insts th' in
    let just i _ = INSTANTIATE_ALL i sth in
    (avs,insts),[],just);;

let RULE_SLV : thm_solver = fun th ->
 if not(is_imp(snd(strip_forall(concl th)))) then
   failwith "RULE_SLV: Bad theorem"
 else
   SOLVER (fun mvs (asl,w) ->
     let avs,th = SPEC_FRESH_ALL th in
     let ant,con = dest_imp(concl th) in
     let inst = term_ty_unify (union avs mvs) con w in
     let sth = INSTANTIATE_ALL inst th in
     let lant = fst(dest_imp(concl sth)) in
     let just i (th :: _) =
       try MP (INSTANTIATE_ALL i sth) th
       with Failure _ ->
         (report(string_of_thm (CONJ (INSTANTIATE_ALL i sth) th));
          fail())
       in
     (avs,inst),[asl,lant],just);;

let SAFE_RULE_SLV : thm_solver =
  fun th -> try RULE_SLV th with Failure _ -> NO_SLV;;

let CHANGED_SLV (slv:solver) : solver =
  fun (_,g as mg) ->
    bind (slv mg)
      (function
         meta,[gl],_ when meta = null_meta && equals_goal gl g -> Empty
       | gstate -> singleton gstate);;

(* ------------------------------------------------------------------------- *)
(* Solvers associated to tactics.                                            *)
(* ------------------------------------------------------------------------- *)

let TACTIC_SLV (tac:tactic) : solver =
  SOLVER (fun _ gl -> tac gl);;

let THM_TACTIC_SLV (ttac:thm_tactic) : thm_solver =
  fun th -> try let tac = ttac th in TACTIC_SLV tac
            with Failure _ -> NO_SLV;;

let ALL_SLV = TACTIC_SLV ALL_TAC;;
let CONJ_SLV = TACTIC_SLV CONJ_TAC;;
let CONTR_SLV = THM_TACTIC_SLV CONTR_TAC;;
let CONV_SLV conv = TACTIC_SLV (CONV_TAC conv);;
let DISCH_SLV = TACTIC_SLV DISCH_TAC;;
let DISJ1_SLV = TACTIC_SLV DISJ1_TAC;;
let DISJ2_SLV = TACTIC_SLV DISJ2_TAC;;
let EQ_SLV = TACTIC_SLV EQ_TAC;;
let GEN_SLV = TACTIC_SLV GEN_TAC;;

(* ------------------------------------------------------------------------- *)
(* Further basic solvers.                                                    *)
(* ------------------------------------------------------------------------- *)

let UNDISCH_THEN_SLV : term -> thm_solver -> solver =
  fun tm tslv (mvs,(asl,w)) ->
    let thp,asl' = remove (fun (_,th) -> aconv (concl th) tm) asl in
    tslv (snd thp) (mvs,(asl',w));;

(* ------------------------------------------------------------------------- *)
(* Solver combinators.                                                       *)
(* ------------------------------------------------------------------------- *)

let THEN_SLV,THENL_SLV =
  let propagate_empty i [] = []
  and propagate_thm th i [] = INSTANTIATE_ALL i th in
  let compose_justs n just1 just2 i ths =
    let ths1,ths2 = chop_list n ths in
    (just1 i ths1)::(just2 i ths2) in
  let rec seqapply mvs l1 l2 = match (l1,l2) with
     ([],[]) -> singleton(null_meta,[],propagate_empty)
   | ((slv:solver)::slvs),((goal:goal)::goals) ->
       bind (slv (mvs,goal)) (fun (mvs1,insts1),gls1,just1 ->
         let goals' = map (inst_goal insts1) goals in
         stream_map
           (fun (mvs2,insts2),gls2,just2 ->
             let just1' i = just1 (compose_insts i insts2) in
             ((union mvs1 mvs2,compose_insts insts1 insts2),
              gls1@gls2,compose_justs (length gls1) just1' just2))
           (seqapply (union mvs1 mvs) slvs goals'))
   | _,_ -> failwith "seqapply: Length mismatch" in
  let justsequence just1 just2 insts2 i ths =
    just1 (compose_insts insts2 i) (just2 i ths) in
  let slvsequence mvs ((mvs1,insts1),gls1,just1) slvl =
    stream_map (fun (mvs2,insts2),gls2,just2 ->
                  let jst = justsequence just1 just2 insts2 in
                  let just = if gls2 <> [] then jst else
                             propagate_thm (jst null_inst []) in
                  (union mvs1 mvs2,compose_insts insts1 insts2),gls2,just)
               (seqapply (union mvs1 mvs) slvl gls1) in
  let (THEN_SLV: solver -> solver -> solver) =
    fun slv1 slv2 (mvs,_ as g) ->
      bind (slv1 g) (fun _,gls,_ as gstate ->
        slvsequence mvs gstate (replicate slv2 (length gls)))
  and (THENL_SLV: solver -> solver list -> solver) =
    fun slv1 slv2l (mvs,_ as g) ->
      bind (slv1 g) (fun _,gls,_ as gstate ->
        if gls = [] then slvsequence mvs gstate []
        else slvsequence mvs gstate slv2l) in
  THEN_SLV,THENL_SLV;;

(* ------------------------------------------------------------------------- *)
(* Sequential chains of solvers.                                             *)
(* ------------------------------------------------------------------------- *)

let EVERY_SLV slvl =
  itlist THEN_SLV slvl ALL_SLV;;

let MAP_EVERY_SLV slvf lst =
  EVERY_SLV (map slvf lst);;

(* ------------------------------------------------------------------------- *)
(* Solvers to augment assumption list.                                       *)
(* ------------------------------------------------------------------------- *)

let (LABEL_SLV: string -> thm_solver) =
  fun s th -> TACTIC_SLV (LABEL_TAC s th);;

let ASSUME_SLV : thm_solver =
  fun th -> TACTIC_SLV (ASSUME_TAC th);;

(* ------------------------------------------------------------------------- *)
(* Manipulation of assumption list.                                          *)
(* ------------------------------------------------------------------------- *)

let FIND_ASSUM_SLV : thm_solver -> term -> solver =
  fun tslv t (_,(asl,_) as g) ->
    tslv(snd(find (fun (_,th) -> concl th = t) asl)) g;;

let POP_ASSUM_SLV : thm_solver -> solver =
  fun tslv ->
    function
      mvs,(((_,th)::asl),w) -> tslv th (mvs,(asl,w))
    | _ -> Empty;;

let ASSUM_LIST_SLV : (thm list -> solver) -> solver =
  fun aslfun (_,(asl,_) as g) -> aslfun (map snd asl) g;;

let POP_ASSUM_LIST_SLV : (thm list -> solver) -> solver =
  fun aslslv (mvs,(asl,w)) -> aslslv (map snd asl) (mvs,([],w));;

let EVERY_ASSUM_SLV : thm_solver -> solver =
  fun tslv -> ASSUM_LIST_SLV (MAP_EVERY_SLV tslv);;

let RULE_ASSUM_SLV : (thm -> thm) -> solver =
  fun rule (_,(asl,_) as g) ->
    THEN_SLV (POP_ASSUM_LIST_SLV(K ALL_SLV))
             (MAP_EVERY_SLV (fun (s,th) -> LABEL_SLV s (rule th)) (rev asl))
             g;;

(* ------------------------------------------------------------------------- *)
(* Concatenation of solvers.                                                 *)
(* ------------------------------------------------------------------------- *)

let CONCAT_SLV (slv1:solver) (slv2:solver) : solver =
  fun g -> concatf (slv1 g) (fun _ -> slv2 g);;

let COLLECT_SLV (slvl:solver list) : solver =
  if slvl = [] then NO_SLV else end_itlist CONCAT_SLV slvl;;

let MAP_COLLECT_SLV (slvf:'a->solver) (lst:'a list) : solver =
  COLLECT_SLV (map slvf lst);;

let COLLECT_ASSUM_SLV (tslv:thm_solver) : solver =
  fun (mvs,(asl,w) as g) -> MAP_COLLECT_SLV (tslv o snd) asl g;;

let COLLECT_X_ASSUM_SLV (tslv:thm_solver) : solver =
  COLLECT_ASSUM_SLV (fun th -> UNDISCH_THEN_SLV (concl th) tslv);;

(* Serve?  Serve la versione con mplusf? *)
let TRY_SLV slv =
  CONCAT_SLV slv ALL_SLV;;

(* Serve?  Serve la versione con mplusf? *)
let rec REPEAT_SLV slv g =
  (CONCAT_SLV (THEN_SLV slv (REPEAT_SLV slv)) ALL_SLV) g;;

(* Serve?  Serve la versione con mplusf? *)
let APPLY_SLV : thm_solver =
  fun th -> try let rule = RULE_SLV th in
                CONCAT_SLV (ACCEPT_SLV th) rule
            with Failure _ -> ACCEPT_SLV th;;

(* ------------------------------------------------------------------------- *)
(* Interleaving of solvers.                                                  *)
(* ------------------------------------------------------------------------- *)

let MPLUS_SLV (slv1:solver) (slv2:solver) : solver =
  fun g -> mplusf (slv1 g) (fun _ -> slv2 g);;

let INTERLEAVE_SLV (slvl:solver list) : solver =
  if slvl = [] then NO_SLV else end_itlist MPLUS_SLV slvl;;

let MAP_INTERLEAVE_SLV (slvf:'a->solver) (lst:'a list) : solver =
  INTERLEAVE_SLV (map slvf lst);;

let INTERLEAVE_ASSUM_SLV (tslv:thm_solver) : solver =
  fun (mvs,(asl,w) as g) -> MAP_INTERLEAVE_SLV (tslv o snd) asl g;;

let INTERLEAVE_X_ASSUM_SLV (tslv:thm_solver) : solver =
  INTERLEAVE_ASSUM_SLV (fun th -> UNDISCH_THEN_SLV (concl th) tslv);;

(* ------------------------------------------------------------------------- *)
(* A simple Prolog-like solver.                                              *)
(* ------------------------------------------------------------------------- *)

parse_as_infix("IS",(10,"right"));;

let IS_DEF = new_definition
  `(IS) = (=):A->A->bool`;;

let IS_SLV : conv -> solver =
  fun conv ->
    let conv' = RAND_CONV conv THENC REWRITE_CONV[IS_DEF] in
    THEN_SLV (TACTIC_SLV (CONV_TAC conv')) REFL_SLV;;

(* ------------------------------------------------------------------------- *)
(* FIXME: The conversion strategy for IS_SLV is hard coded!                  *)
(* ------------------------------------------------------------------------- *)

let PROLOG_SLV conv thl : solver =
  let RAW_PROLOG_SLV thl : solver =
    let rec PROLOG_SLV g =
      CONCAT_SLV (IS_SLV conv) (MAP_COLLECT_SLV STEP_SLV thl) g
    and STEP_SLV : thm_solver =
      fun th ->
        try let rule = RULE_SLV th in
            EVERY_SLV [rule; TACTIC_SLV (REPEAT CONJ_TAC); PROLOG_SLV]
        with Failure _ -> ACCEPT_SLV th in
    THEN_SLV (TACTIC_SLV (REPEAT CONJ_TAC)) PROLOG_SLV in
  let thl' = itlist (fun th acc -> striplist CONJ_PAIR th @ acc) thl [] in
  RAW_PROLOG_SLV thl';;

(* ------------------------------------------------------------------------- *)
(* Tests and examples.                                                       *)
(* ------------------------------------------------------------------------- *)

let sols = take 10
  (solve (POP_ASSUM_LIST_SLV (PROLOG_SLV NO_CONV))
         `??a b:A.
             (!x y z. padre x y /\ antenato y z ==> antenato x z) &&
             (!x y. padre x y ==> antenato x y) &&
             padre pippo pluto && padre pluto paperino
             ?- antenato a b`);;
map (concl o snd) sols;;

let sols = take 10
  (solve (POP_ASSUM_LIST_SLV (PROLOG_SLV NO_CONV))
         `??a b:A.
             (!x y z. padre x y /\ antenato y z ==> antenato x z) &&
             (!x. antenato x x) &&
             padre pippo pluto && padre pluto paperino
             ?- antenato a b`);;
map (concl o snd) sols;;

let sols = take 10
  (solve (POP_ASSUM_LIST_SLV (PROLOG_SLV NO_CONV))
         `??a b:A.
             (!x y z. persona z /\ padre x y /\ antenato y z ==> antenato x z) &&
             (!x. persona x ==> antenato x x) &&
             padre pippo pluto && padre pluto paperino &&
             persona pippo && persona pluto && persona paperino
             ?- antenato a b`);;
map (concl o snd) sols;;

(setify o map (concl o snd) o take 100 o
 solve (POP_ASSUM_LIST_SLV (PROLOG_SLV NO_CONV)))
  `??a b:A.
      (!x y z. antenato x y /\ antenato y z ==> antenato x z) &&
      (!x. antenato x x) &&
      (!x y. padre x y ==> antenato x y) &&
      padre pippo pluto && padre pluto paperino
      ?- antenato a b`;;

(* ------------------------------------------------------------------------- *)
(* Esempio di un caso in cui con le eccezioni non si troverebbe nessuna      *)
(* soluzione.                                                                *)
(* Infatti, con le eccezioni, dopo aver trovato la soluzione parziale        *)
(* `padre a b`, non si saprebbe come continuare.                             *)
(* In questo caso, il punto cruciale è come procedere per risolvere una      *)
(* congiunzione: la struttura """CONJ_TAC THEN PROLOG_TAC""" non permette,   *)
(* una volta trovata una unficazione sulla prima "branch" di ritrattarla se  *)
(* la seconda branch fallisce.                                               *)
(* ------------------------------------------------------------------------- *)

(*
ITAUT `(!x y z. padre x y /\ padre y z ==> nonno x z) /\
       padre c d /\
       padre a c /\
       padre a b
       ==> ?x:A. nonno a x`;;

(map (concl o snd) o take 100 o
 solve (POP_ASSUM_LIST_SLV (PROLOG_SLV NO_CONV)))
  `??x:A. (!x y z. padre x y /\ padre y z ==> nonno x z) &&
          padre c d &&
          padre a c &&
          padre a b
          ?- nonno a x`;;
*)
