(* ========================================================================= *)
(* Semicertified interactive logic programming.                              *)
(* ========================================================================= *)

needs "streams.hl";;

type mgoal = term list * goal;;

type solver = mgoal -> goalstate stream;;

type thm_solver = thm -> solver;;

(* ------------------------------------------------------------------------- *)
(* Meta goals.                                                               *)
(* ------------------------------------------------------------------------- *)

parse_as_binder "??";;
parse_as_infix ("?-",(0,"right"));;
parse_as_infix ("&&",(1,"right"));;

let META = new_definition `(??) = (?):(A->bool)->bool`;;
let ENTAILS = new_definition `(?-) = (==>)`;;
let MAND = new_definition `(&&) = (/\)`;;

let is_meta = is_binder "??";;
let dest_meta = dest_binder "??";;
let strip_meta = splitlist dest_meta;;

let is_mand = is_binary "&&";;
let dest_mand = dest_binary "&&";;
let split_mand = striplist dest_mand;;

let is_entails = is_binary "?-";;
let dest_entails = dest_binary "?-";;

let dest_mgoal (tm:term) : mgoal =
  let mvs,rtm = strip_meta tm in
  let hpl,w = try let btm,htm = dest_entails rtm in
                  rev(split_mand btm),htm
              with Failure _ -> [],rtm in
  let asl = map (fun tm -> "",ASSUME tm) hpl in
  mvs,(asl,w);;

(* ------------------------------------------------------------------------- *)
(* Run a solver.                                                             *)
(* ------------------------------------------------------------------------- *)

let wrapup : goalstate -> (term list * instantiation) * thm  =
  fun metas,gls,just ->
    if gls <> [] then failwith "wrapup: Unsolved goals" else
    let th = just null_inst [] in
    metas,th;;

let solve : solver -> term -> (term list * thm) stream =
  let run_solver g slv = stream_mapfilter wrapup (slv g)
  and mk_veq inst v = mk_eq(v,instantiate inst v) in
  fun slv tm ->
    let mvs,g as mg = dest_mgoal tm in
    let mk_veqs inst = map (mk_veq inst) mvs in
    let p ((mvs',inst),th) =
      mk_veqs inst,th in
    stream_map p (run_solver (dest_mgoal tm) slv);;

(* ------------------------------------------------------------------------- *)
(* Common pattern for building "singleton" solvers.                          *)
(* ------------------------------------------------------------------------- *)

let SOLVER (f:term list -> goal -> goalstate) : solver =
  fun mvs,gl -> try singleton (f mvs gl) with Failure _ -> empty;;

(* ------------------------------------------------------------------------- *)
(* Basic solvers.                                                            *)
(* ------------------------------------------------------------------------- *)

let NO_SLV : solver =
  fun _ -> empty;;

let REFL_SLV =
  SOLVER (fun mvs (asl,w) ->
    let l,r = dest_eq w in
    let inst = term_unify mvs l r in
    let sth = ALPHA (instantiate inst l) (instantiate inst r) in
    let just i _ = INSTANTIATE_ALL i sth in
    ([],inst),[],just);;

take 10 (solve REFL_SLV `??m n. m + n = 1 + 2`);;
take 10 (solve REFL_SLV `??m n. m + n = a + b`);;

let SPEC_FRESH th =
  let v,th' = SPEC_VAR th in
  let v' = genvar(type_of v) in
  v',INST [v',v] th';;

let SPEC_FRESH_ALL = splitlist SPEC_FRESH;;

let ACCEPT_SLV : thm_solver =
  fun th -> SOLVER (fun mvs (asl,w) ->
    let avs,th' = SPEC_FRESH_ALL th in
    let inst = term_unify (union avs mvs) (concl th') w in
    let sth = INSTANTIATE inst th' in
    let just i _ = INSTANTIATE_ALL i sth in
    (avs,inst),[],just);;

let RULE_SLV : thm_solver = fun th ->
 if not(is_imp(snd(strip_forall(concl th)))) then
   failwith "RULE_SLV: Bad theorem"
 else
   SOLVER (fun mvs (asl,w) ->
     let avs,th = SPEC_FRESH_ALL th in
     let ant,con = dest_imp(concl th) in
     let evs = filter (fun v -> vfree_in v ant && not (vfree_in v con)) avs in
     let inst = term_unify (union avs mvs) con w in
     let sth = INSTANTIATE inst th in
     let lant = fst(dest_imp(concl sth)) in
     let just i (th :: _) =
       try MP (INSTANTIATE_ALL i sth) th
       with Failure _ ->
         (report(string_of_thm (CONJ (INSTANTIATE_ALL i sth) th));
          fail())
       in
     (avs,inst),[asl,lant],just);;

let SAFE_RULE_SLV : thm_solver =
  fun th -> try RULE_SLV th with Failure _ -> NO_SLV;;

(* ------------------------------------------------------------------------- *)
(* Solvers associated to tactics.                                            *)
(* ------------------------------------------------------------------------- *)

let TACTIC_SLV (tac:tactic) : solver =
  SOLVER (fun _ gl -> tac gl);;

let THM_TACTIC_SLV (ttac:thm_tactic) : thm_solver =
  fun th -> try let tac = ttac th in TACTIC_SLV tac
            with Failure _ -> NO_SLV;;

let ALL_SLV = TACTIC_SLV ALL_TAC;;
let CONJ_SLV = TACTIC_SLV CONJ_TAC;;
let CONTR_SLV = THM_TACTIC_SLV CONTR_TAC;;
let CONV_SLV conv = TACTIC_SLV (CONV_TAC conv);;
let DISCH_SLV = TACTIC_SLV DISCH_TAC;;
let DISJ1_SLV = TACTIC_SLV DISJ1_TAC;;
let DISJ2_SLV = TACTIC_SLV DISJ2_TAC;;
let EQ_SLV = TACTIC_SLV EQ_TAC;;
let GEN_SLV = TACTIC_SLV GEN_TAC;;

(* ------------------------------------------------------------------------- *)
(* Further basic solvers.                                                    *)
(* ------------------------------------------------------------------------- *)

let UNDISCH_THEN_SLV : term -> thm_solver -> solver =
  fun tm tslv (mvs,(asl,w)) ->
    let thp,asl' = remove (fun (_,th) -> aconv (concl th) tm) asl in
    tslv (snd thp) (mvs,(asl',w));;

(* ------------------------------------------------------------------------- *)
(* Solver combinators.                                                       *)
(* ------------------------------------------------------------------------- *)

let THEN_SLV,THENL_SLV =
  let propagate_empty i [] = []
  and propagate_thm th i [] = INSTANTIATE_ALL i th in
  let compose_justs n just1 just2 i ths =
    let ths1,ths2 = chop_list n ths in
    (just1 i ths1)::(just2 i ths2) in
  let rec seqapply mvs l1 l2 = match (l1,l2) with
     ([],[]) -> singleton(null_meta,[],propagate_empty)
   | ((slv:solver)::slvs),((goal:goal)::goals) ->
       bind (slv (mvs,goal)) (fun (mvs1,insts1),gls1,just1 ->
         let goals' = map (inst_goal insts1) goals in
         stream_map
           (fun (mvs2,insts2),gls2,just2 ->
             let just1' i = just1 (compose_insts i insts2) in
             ((union mvs1 mvs2,compose_insts insts1 insts2),
              gls1@gls2,compose_justs (length gls1) just1' just2))
           (seqapply (union mvs1 mvs) slvs goals'))
   | _,_ -> failwith "seqapply: Length mismatch" in
  let justsequence just1 just2 insts2 i ths =
    just1 (compose_insts insts2 i) (just2 i ths) in
  let slvsequence mvs ((mvs1,insts1),gls1,just1) slvl =
    stream_map (fun (mvs2,insts2),gls2,just2 ->
                  let jst = justsequence just1 just2 insts2 in
                  let just = if gls2 <> [] then jst else
                             propagate_thm (jst null_inst []) in
                  (union mvs1 mvs2,compose_insts insts1 insts2),gls2,just)
               (seqapply (union mvs1 mvs) slvl gls1) in
  let (THEN_SLV: solver -> solver -> solver) =
    fun slv1 slv2 (mvs,_ as g) ->
      bind (slv1 g) (fun _,gls,_ as gstate ->
        slvsequence mvs gstate (replicate slv2 (length gls)))
  and (THENL_SLV: solver -> solver list -> solver) =
    fun slv1 slv2l (mvs,_ as g) ->
      bind (slv1 g) (fun _,gls,_ as gstate ->
        if gls = [] then slvsequence mvs gstate []
        else slvsequence mvs gstate slv2l) in
  THEN_SLV,THENL_SLV;;

(* ------------------------------------------------------------------------- *)
(* Tests and examples.                                                       *)
(* ------------------------------------------------------------------------- *)

take 10 (solve (THEN_SLV CONJ_SLV REFL_SLV)
  `??m n. m + n = n + m /\ n + n = n + 1`);;

take 10 (solve (THENL_SLV CONJ_SLV [ACCEPT_SLV ADD_SYM; REFL_SLV])
  `??m n. m + n = n + m /\ n + n = n + 1`);;

take 10 (solve (THENL_SLV CONJ_SLV [REFL_SLV; ACCEPT_SLV ADD_SYM])
  `??m n. m + n = n + m /\ n + n = n + 1`);;

take 10 (solve (THEN_SLV (RULE_SLV MOD_0) (ACCEPT_SLV (ASSUME `~(b = 0)`)))
  `??a b c. ~(b = 0) ?- a MOD b = c`);;

(* ------------------------------------------------------------------------- *)
(* Parallel combination of solvers.                                          *)
(* ------------------------------------------------------------------------- *)

let ORELSE_SLV (slv1:solver) (slv2:solver) : solver =
  fun g -> concatf (slv1 g) (fun _ -> slv2 g);;

let TRY_SLV slv =
  ORELSE_SLV slv ALL_SLV;;

let rec REPEAT_SLV slv g =
  (ORELSE_SLV (THEN_SLV slv (REPEAT_SLV slv)) ALL_SLV) g;;

let EVERY_SLV slvl =
  itlist THEN_SLV slvl ALL_SLV;;

let FIRST_SLV (slvl:solver list) : solver =
  if slvl = [] then NO_SLV else end_itlist ORELSE_SLV slvl;;

let MAP_EVERY_SLV slvf lst =
  EVERY_SLV (map slvf lst);;

let MAP_FIRST_SLV slvf lst =
  FIRST_SLV (map slvf lst);;

let CHANGED_SLV (slv:solver) : solver =
  fun (_,g as mg) ->
    bind (slv mg)
      (function
         meta,[gl],_ when meta = null_meta && equals_goal gl g -> empty
       | gstate -> singleton gstate);;

let APPLY_SLV : thm_solver =
  fun th -> try let rule = RULE_SLV th in
                ORELSE_SLV (ACCEPT_SLV th) rule
            with Failure _ -> ACCEPT_SLV th;;

(* ------------------------------------------------------------------------- *)
(* Parallel (fair) combination of solvers.                                   *)
(* ------------------------------------------------------------------------- *)

let MPLUS_SLV (slv1:solver) (slv2:solver) : solver =
  fun g -> mplusf (slv1 g) (fun _ -> slv2 g);;

let MPLUS_LIST_SLV : solver list -> solver =
  fun slvl g -> if slvl = [] then empty else
                end_itlist MPLUS_SLV slvl g;;

let MAP_MPLUS_LIST_SLV slvf lst =
  MPLUS_LIST_SLV (map slvf lst);;

let MPLUS_ASSUM_SLV : thm_solver -> solver =
  fun tslv (mvs,(asl,w) as g) -> MAP_MPLUS_LIST_SLV (tslv o snd) asl g;;

let MPLUS_X_ASSUM_SLV : thm_solver -> solver =
  fun tslv -> MPLUS_ASSUM_SLV (fun th -> UNDISCH_THEN_SLV (concl th) tslv);;

(* ------------------------------------------------------------------------- *)
(* Tactics to augment assumption list.                                       *)
(* ------------------------------------------------------------------------- *)

let (LABEL_SLV: string -> thm_solver) =
  fun s th -> TACTIC_SLV (LABEL_TAC s th);;

let ASSUME_SLV : thm_solver =
  fun th -> TACTIC_SLV (ASSUME_TAC th);;

(* ------------------------------------------------------------------------- *)
(* Manipulation of assumption list.                                          *)
(* ------------------------------------------------------------------------- *)

let FIND_ASSUM_SLV : thm_solver -> term -> solver =
  fun tslv t (_,(asl,_) as g) ->
    tslv(snd(find (fun (_,th) -> concl th = t) asl)) g;;

let POP_ASSUM_SLV : thm_solver -> solver =
  fun tslv ->
    function
      mvs,(((_,th)::asl),w) -> tslv th (mvs,(asl,w))
    | _ -> empty;;

let ASSUM_LIST_SLV : (thm list -> solver) -> solver =
  fun aslfun (_,(asl,_) as g) -> aslfun (map snd asl) g;;

let POP_ASSUM_LIST_SLV : (thm list -> solver) -> solver =
  fun aslslv (mvs,(asl,w)) -> aslslv (map snd asl) (mvs,([],w));;

let EVERY_ASSUM_SLV : thm_solver -> solver =
  fun tslv -> ASSUM_LIST_SLV (MAP_EVERY_SLV tslv);;

let FIRST_ASSUM_SLV : thm_solver -> solver =
  fun tslv (mvs,(asl,w) as g) -> MAP_FIRST_SLV (tslv o snd) asl g;;

let FIRST_X_ASSUM_SLV : thm_solver -> solver =
  fun tslv -> FIRST_ASSUM_SLV (fun th -> UNDISCH_THEN_SLV (concl th) tslv);;

let USE_ASSUM_SLV : thm_solver -> solver =
  fun tslv (_,(asl,_) as g) -> MAP_FIRST_SLV (fun (_,th) -> tslv th) asl g;;

let RULE_ASSUM_SLV : (thm -> thm) -> solver =
  fun rule (_,(asl,_) as g) ->
    THEN_SLV (POP_ASSUM_LIST_SLV(K ALL_SLV))
             (MAP_EVERY_SLV (fun (s,th) -> LABEL_SLV s (rule th)) (rev asl))
             g;;

(* ------------------------------------------------------------------------- *)
(* A simple Prolog-like solver.                                              *)
(* ------------------------------------------------------------------------- *)

let PROLOG_SLV thl : solver =
  let rec PROLOG_SLV g = MAP_FIRST_SLV STEP_SLV thl g
  and STEP_SLV : thm_solver =
    fun th -> try let rule = RULE_SLV th in
                      EVERY_SLV [rule; REPEAT_SLV CONJ_SLV; PROLOG_SLV]
              with Failure _ -> ACCEPT_SLV th in
  THEN_SLV (REPEAT_SLV CONJ_SLV) PROLOG_SLV;;

(* ------------------------------------------------------------------------- *)
(* Tests and examples.                                                       *)
(* ------------------------------------------------------------------------- *)

let sols = take 10
  (solve (POP_ASSUM_LIST_SLV PROLOG_SLV)
         `??a b:A.
             (!x y z. padre x y /\ antenato y z ==> antenato x z) &&
             (!x y. padre x y ==> antenato x y) &&
             padre pippo pluto && padre pluto paperino
             ?- antenato a b`);;
map (concl o snd) sols;;

let sols = take 10
  (solve (POP_ASSUM_LIST_SLV PROLOG_SLV)
         `??a b:A.
             (!x y z. padre x y /\ antenato y z ==> antenato x z) &&
             (!x. antenato x x) &&
             padre pippo pluto && padre pluto paperino
             ?- antenato a b`);;
map (concl o snd) sols;;

let sols = take 10
  (solve (POP_ASSUM_LIST_SLV PROLOG_SLV)
         `??a b:A.
             (!x y z. persona z /\ padre x y /\ antenato y z ==> antenato x z) &&
             (!x. persona x ==> antenato x x) &&
             padre pippo pluto && padre pluto paperino &&
             persona pippo && persona pluto && persona paperino
             ?- antenato a b`);;
map (concl o snd) sols;;

(setify o map (concl o snd) o take 100 o
 solve (POP_ASSUM_LIST_SLV PROLOG_SLV))
  `??a b:A.
      (!x y z. antenato x y /\ antenato y z ==> antenato x z) &&
      (!x. antenato x x) &&
      (!x y. padre x y ==> antenato x y) &&
      padre pippo pluto && padre pluto paperino
      ?- antenato a b`;;

(* ------------------------------------------------------------------------- *)
(* Esempio di un caso in cui con le eccezioni non si troverebbe nessuna      *)
(* soluzione.                                                                *)
(* Infatti, con le eccezioni, dopo aver trovato la soluzione parziale        *)
(* `padre a b`, non si saprebbe come continuare.                             *)
(* ------------------------------------------------------------------------- *)

(map (concl o snd) o take 100 o solve (POP_ASSUM_LIST_SLV PROLOG_SLV))
  `??x:A. (!x y z. padre x y /\ padre y z ==> nonno x z) &&
          padre c d &&
          padre a c &&
          padre a b
          ?- nonno a x`;;
