(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

let ALL2_RULES = prove
 (`(!R:A->B->bool. ALL2 R [] []) /\
   (!R h:A h':B t t'. R h h' /\ ALL2 R t t'
                      ==> ALL2 R (CONS h t) (CONS h' t'))`,
  REWRITE_TAC[ALL2]);;

let ALL2_NIL,ALL2_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] ALL2_RULES);;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVL_RULES,EVL_INDUCT,EVL_CASES = new_inductive_definition
  `(!env a x. RELASSOC a env x ==> EVL env (Symbol a) x) /\
   (!env env' env'' fn fn' vars body args args' ret.
       EVL env fn fn' /\ MATCHPROC fn' vars body /\
       ALL2 (EVL env) args args' /\
       ZIPPED args' vars env' /\
       env'' IS APPEND env' env /\
       EVL env'' body ret
       ==> EVL env (List (CONS fn args)) ret) /\
   (!env rest. EVL env (List (CONS (Symbol "lambda") rest))
                       (List (CONS (Symbol "lambda") rest))) /\
   (!env sexp l l'. MATCHTAGGED "list" sexp l /\ ALL2 (EVL env) l l'
                    ==> EVL env sexp (List l')) /\
   (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                      ==> EVL env sexp quoted)`;;

let [EVL_SYMB; EVL_APP; EVL_LAMBDA; EVL_LIST; EVL_QUOTED] = CONJUNCTS EVL_RULES;;

(* ------------------------------------------------------------------------- *)
(* The classical quine in scheme.  Note that our evaluation do not use       *)
(* dynamic (non-static) scope. But this code do not depend on this.          *)
(*                                                                           *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Prolog-style program for the evaluation of lisp programs.                 *)
(* ------------------------------------------------------------------------- *)

let EVL_SLV = PROLOG_SLV (REWRITE_CONV[APPEND; APPEND_NIL])
  [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES;
   REWRITE_RULE[FORALL_AND_THM] LISTREL_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVL_RULES; BOOL_EQ_CLAUSES; EQ_REFL];;
let lispeval = solve EVL_SLV;;

take 10 (lispeval
  `??ret. EVL [Symbol "a","x"] (Symbol "x") ret`);;
take 10 (lispeval
  `??ret. EVL [] '(list) ret`);;
take 10 (lispeval
  `??ret. EVL [] '(list (list)) ret`);;
take 10 (lispeval
  `??ret. EVL [Symbol "x", "a"] '(list a) ret`);;

(snd o get o lispeval) `??ret. EVL [] '((lambda (x) x) (list)) ret`;;
(snd o get o lispeval) `??ret. EVL [Symbol "a","x"] '(list x) ret`;;

(snd o get o lispeval)
  `??ret. EVL []
            '((lambda (x) (list x (list (quote quote) x)))
              (quote (lambda (x) (list x (list (quote quote) x)))))
            ret`;;

(* ------------------------------------------------------------------------- *)
(* Automatic quine generation.                                               *)
(* ------------------------------------------------------------------------- *)

let STRING_RULES,STRING_INDUCT,STRING_CASES = new_inductive_definition
  `STRING "list" /\
   STRING "quote" /\
   STRING "x" /\
   STRING "y"`;;

take 5 (solve(PROLOG_SLV NO_CONV [STRING_RULES]) `??s. STRING s`);;

let LISTOF_RULES,LISTOF_INDUCT,LISTOF_CASES = new_inductive_definition
  `LISTOF P [] /\
   (!h:A t. P h /\ LISTOF P t ==> LISTOF P (CONS h t))`;;

let LISTOF_STRING_RULES =
  ISPEC `STRING` LISTOF_RULES;;

take 10 (solve (PROLOG_SLV NO_CONV [STRING_RULES; LISTOF_STRING_RULES])
               `??l. LISTOF STRING l`);;

let LISPTERM_RULES,LISPTERM_INDUCT,LISPTERM_CASES = new_inductive_definition
  `(!s. STRING s ==> LISPTERM (Symbol s)) /\
   (!l. LISTOF LISPTERM l ==> LISPTERM (List l)) /\
   (!vars vars' body.
      LISTOF STRING vars /\ vars' IS MAP Symbol vars /\ LISPTERM body
      ==> LISPTERM (List [Symbol "lambda"; List vars'; body]))`;;
