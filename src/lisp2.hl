(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

let ALL2_RULES = prove
 (`(!R:A->B->bool. ALL2 R [] []) /\
   (!R h:A h':B t t'. R h h' /\ ALL2 R t t'
                      ==> ALL2 R (CONS h t) (CONS h' t'))`,
  REWRITE_TAC[ALL2]);;

let ALL2_NIL,ALL2_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] ALL2_RULES);;

(* Rev-Assoc relation. *)
let RELASSOC_RULES,RELASSOC_INDUCT,RELASSOC_CASES = new_inductive_definition
  `(!k:A v:B l. RELASSOC k (CONS (v,k) l) v) /\
   (!k k' v v' l. ~(k = k') /\ RELASSOC k l v'
                  ==> RELASSOC k (CONS (v,k') l) v')`;;

let RELASSOC_HEAD,REALASSOC_TAIL = CONJ_PAIR RELASSOC_RULES;;

(* Zip-relation. *)
let ZIPPED_RULES,ZIPPED_INDUCT,ZIPPED_CASES = new_inductive_definition
  `ZIPPED [] [] [] /\
   (!x xs y ys zs. ZIPPED xs ys zs
                   ==> ZIPPED (CONS x xs) (CONS y ys) (CONS (x,y) zs))`;;

let ZIPPED_NIL,ZIPPED_CONS = CONJ_PAIR ZIPPED_RULES;;

(* ------------------------------------------------------------------------- *)
(* Helpers for sexp analyis.                                                 *)
(* ------------------------------------------------------------------------- *)

(* Matcher for lisp-like lambda forms. *)
let MATCHPROC_RULES,MATCHPROC_INDUCT,MATCHPROC_CASES = new_inductive_definition
  `!sexp vlist vars body.
     MATCHTAGGED "lambda" sexp [List vlist; body] /\
     ALL2 MATCHSYMB vlist vars
     ==> MATCHPROC sexp vars body`;;

let _ = prove
 (`MATCHPROC '(lambda (x y) (p x y)) ["x"; "y"] '(p x y)`,
  GEN_REWRITE_TAC I [MATCHPROC_CASES] THEN
  EXISTS_TAC `[Symbol "x"; Symbol "y"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHSYMB_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_ACCEPT_TAC MATCHSYMB_RULES; MATCH_ACCEPT_TAC ALL2_NIL]);;

let MATCHBETA_RULES,MATCHBETA_INDUCT,MATCHBETA_CASES = new_inductive_definition
  `!fn vars args body.
      MATCHPROC fn vars body
      ==> MATCHBETA (List (CONS fn args)) vars body args`;;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES,EVAL_INDUCT,EVAL_CASES = new_inductive_definition
  `(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
   (!env env' env'' fn fn' vars body args args' ret.
       EVAL env fn fn' /\ MATCHPROC fn' vars body /\
       ALL2 (EVAL env) args args' /\
       ZIPPED args' vars env' /\
       APPEND env' env = env'' /\
       EVAL env'' body ret
       ==> EVAL env (List (CONS fn args)) ret) /\
   (!env rest. EVAL env (List (CONS (Symbol "lambda") rest))
                       (List (CONS (Symbol "lambda") rest))) /\
   (!env sexp l l'. MATCHTAGGED "list" sexp l /\ ALL2 (EVAL env) l l'
                    ==> EVAL env sexp (List l')) /\
   (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                      ==> EVAL env sexp quoted)`;;

let [EVAL_SYMB; EVAL_APP; EVAL_LAMBDA; EVAL_LIST; EVAL_QUOTED] =
  CONJUNCTS EVAL_RULES;;

(* ------------------------------------------------------------------------- *)
(* The classical quine in scheme.  Note that our evaluation do not use       *)
(* dynamic (non-static) scope. But this code do not depend on this.          *)
(*                                                                           *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

(*
let QUINE = prove
 (`let quine = '((lambda (x) (list x (list (quote quote) x)))
                 (quote (lambda (x) (list x (list (quote quote) x))))) in
   EVAL [] quine quine`,
  LET_TAC THEN POP_ASSUM SUBST_VAR_TAC THEN
  MATCH_MP_TAC EVAL_BETA THEN
  REWRITE_TAC[APPEND_NIL; IMP_CONJ; RIGHT_EXISTS_AND_THM] THEN
  MAP_EVERY EXISTS_TAC
   [`['(lambda (x) (list x (list (quote quote) x))), "x"]`;
    `["x"]`;
    `'(list x (list (quote quote) x))`;
    `['(quote (lambda (x) (list x (list (quote quote) x))))]`] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC MATCHBETA_RULES THEN MATCH_MP_TAC MATCHPROC_RULES THEN
   EXISTS_TAC `[Symbol "x"]` THEN
   CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
   MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL; MATCHSYMB_RULES];
   ALL_TAC] THEN
  EXISTS_TAC `['(lambda (x) (list x (list (quote quote) x)))]` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
   MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ZIPPED_CONS THEN MATCH_ACCEPT_TAC ZIPPED_NIL; ALL_TAC] THEN
  MATCH_MP_TAC EVAL_LIST THEN
  EXISTS_TAC `[Symbol "x"; '(list (quote quote) x)]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
  MATCH_MP_TAC EVAL_LIST THEN EXISTS_TAC `['(quote quote); Symbol "x"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
  MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD);;
*)

(* ------------------------------------------------------------------------- *)
(* Prolog-style program for the evaluation of lisp expressions.              *)
(* ------------------------------------------------------------------------- *)

let BOOL_EQ_CLAUSES = ITAUT `~(T = F) /\ ~(F = T)`;;

(*
let APPEND_RULES = prove
 (`(!xs:A list. APPEND [] xs = xs) /\
   (!x xs ys zs. APPEND xs ys = zs ==> APPEND (CONS x xs) ys = CONS x zs)`,
  REWRITE_TAC[APPEND; CONS_11]);;
*)

(*
let EVAL_SLV = PROLOG_SLV (REWRITE_CONV[APPEND; APPEND_NIL])
  [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL];;
*)

let EVAL_SLV = PROLOG_SLV NO_CONV
  [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES; APPEND_HORN;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL];;
let lispeval = solve EVAL_SLV;;

(* Test APPEND *)
take 10 (lispeval `??ret. APPEND [1] [2] = ret`);;
take 10 (lispeval `??ret. APPEND [1;3] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [2;4;5] [] = ret`);;

(* Test MATCHSYMB *)
take 10 (lispeval `??ret. MATCHSYMB (Symbol "a") ret`);;
take 10 (lispeval `??ret. MATCHSYMB ret "a"`);;
take 10 (lispeval `??ret. MATCHSYMB '(a b) ret`);;

(* Test MATCHTAGGED *)
take 10 (lispeval `??s ret. MATCHTAGGED s '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "tag" '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "list" '(tag x y) ret`);;

(* Test ALL2 *)
take 10 (lispeval `??a. a = 1`);;
take 10 (lispeval `??a. ALL2 (=) [] a`);;
take 10 (lispeval `??a. ALL2 (=) a []`);;
take 10 (lispeval `??a. ALL2 (=) [1] [a]`);;
take 10 (lispeval `??a. ALL2 (=) [1] a`);;
take 3 (lispeval `??a b. ALL2 (=) a b`);;

(* Test RELASSOC *)
take 10 (lispeval `??k ret. RELASSOC k [0,T; 1,F] ret`);;
take 10 (lispeval `??k. RELASSOC k [0,T; 1,F] 1`);;

(* Test ZIPPED *)
take 10 (lispeval `??ret. ZIPPED [] [] ret`);;
take 10 (lispeval `??ret. ZIPPED [] ret []`);;
take 10 (lispeval `??ret. ZIPPED [1] [T] ret`);;
take 10 (lispeval `??ret. ZIPPED [1] ret [1,T]`);;

(* Test MATCHPROC *)
take 10 (lispeval `??vars body. MATCHPROC '(lambda (x) (x x)) vars body`);;

(* Test MATCHBETA_RULES *)
take 10 (lispeval
  `??vars body args.
      MATCHBETA '((lambda (x) body) arg) vars body args`);;

take 10 (lispeval
  `??ret. EVAL [Symbol "a","x"] (Symbol "x") ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list) ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list (list)) ret`);;
take 10 (lispeval
  `??ret. EVAL [Symbol "x", "a"] '(list a) ret`);;

(snd o get o lispeval) `??ret. EVAL [] '((lambda (x) x) (list)) ret`;;
(snd o get o lispeval) `??ret. EVAL [Symbol "a","x"] '(list x) ret`;;

(* ------------------------------------------------------------------------- *)
(* Evaluation of a quine.                                                    *)
(* ------------------------------------------------------------------------- *)

(snd o get o lispeval)
  `??ret. EVAL []
            '((lambda (x) (list x (list (quote quote) x)))
              (quote (lambda (x) (list x (list (quote quote) x)))))
            ret`;;

(* ------------------------------------------------------------------------- *)
(* Automatic quine generation.                                               *)
(* ------------------------------------------------------------------------- *)

let GEN_SYMBOL_SLV v : solver =
  CONCAT_SLV (META_EXISTS_SLV v [] `Symbol "x"`)
             (META_EXISTS_SLV v [] `Symbol "quote"`);;

gg `??x:sexp. x = x`;;
ee (THEN_SLV (GEN_SYMBOL_SLV `x:sexp`) REFL_SLV);;
take 10 (top_thms());;

let rec GENLIST_SLV v =
  let ty = hd(snd(dest_type(type_of v))) in
  let htm = genvar ty in
  let ltm =
    try mk_icomb(mk_icomb(`CONS:A->A list->A list`,htm),v)
    with Failure _ -> failwith "PIPPO" in
  fun (genslv : term -> solver) g ->
    MPLUS_SLV
      (META_EXISTS_SLV v [] `[]:sexp list`)
      (THEN_SLV (META_EXISTS_SLV v [] ltm)
                (THEN_SLV (genslv htm) (GENLIST_SLV v genslv)))
      g;;

gg `??x:sexp list. x = x`;;
ee (GENLIST_SLV `x:sexp list` GEN_SYMBOL_SLV);;
ee REFL_SLV;;
take 20 (top_thms());;

let rec GEN_LISPTERM_SLV v g =
  INTERLEAVE_SLV
    [GEN_SYMBOL_SLV v;
     GEN_LISPTERM_LIST_SLV v;
     GEN_LISPTERM_APP_SLV v;
     GEN_LISPTERM_QUOTE_SLV v;
     GEN_LISPTERM_LAMBDA_SLV v]
    g
and GEN_LISPTERM_QUOTE_SLV v g =
  THEN_SLV
    (META_EXISTS_SLV v [] `List (CONS (Symbol "quote") term)`)
    (GEN_LISPTERM_SLV `term:sexp`)
    g
and GEN_LISPTERM_LIST_SLV v g =
  THEN_SLV
    (META_EXISTS_SLV v [] `List (CONS (Symbol "list") terms)`)
    (GEN_LISPTERMS_SLV `terms:sexp list`)
    g
and GEN_LISPTERM_APP_SLV v g =
  THEN_SLV
    (META_EXISTS_SLV v [] `List (CONS f (CONS x rest))`)
    (THEN_SLV (GEN_LISPTERM_SLV `f:sexp`)
              (THEN_SLV (GEN_LISPTERM_SLV `x:sexp`)
                        (GEN_LISPTERMS_SLV `rest:sexp list`)))
    g
and GEN_LISPTERM_LAMBDA_SLV v g =
  THEN_SLV
    (META_EXISTS_SLV v [] `List [Symbol "lambda"; List vars; term]`)
    (THEN_SLV (GEN_LISPTERM_SLV `term:sexp`)
              (GENLIST_SLV `vars:sexp list` GEN_SYMBOL_SLV))
    g
and GEN_LISPTERMS_SLV v g =
  GENLIST_SLV v GEN_LISPTERM_SLV g;;

gg `??x:sexp. x = x`;;
ee (THEN_SLV (GEN_LISPTERM_SLV `x:sexp`) REFL_SLV);;
take 20 (top_thms());;

(*
let mk_app f args =
  mk_comb(`List`, mk_list(f::args,`:sexp`));;

let mk_lambda vars body =
  let vlist = mk_comb(`List`, mk_list(vars,`:sexp`)) in
  mk_comb(`List`,
    mk_list([ ` Symbol "lambda"`; vlist; body],`:sexp`));;

mk_app `Symbol "f"` [`Symbol "x"`];;
mk_lambda [`Symbol "x"`; `Symbol "y"`] `'(x y)`;;

let qtm = mk_app (mk_lambda [`Symbol "x"`] `body:sexp`) [`arg:sexp`];;
mk_eq(qtm,qtm);;

`??body arg y. y = '((lambda (x) body) arg)`;;
*)


(* ------------------------------------------------------------------------- *)
(* Printer for mgoalstacs.                                                   *)
(* ------------------------------------------------------------------------- *)

let print_goalstate (gs:goalstate) =
  let (_,gl,_) = gs in
  if gl = [] then () else
  do_list print_goal (rev gl);;

let (print_mgoalstack:mgoalstack->unit) =
  fun mgls ->
    if mgls = [] then Format.print_string "Empty mgoalstack" else
    let mgl = hd mgls in
    if mgl = Empty then Format.print_string "No (more) solutions" else
    print_goalstate (get mgl);;

#install_printer print_mgoalstack;;



mk_comb(`(??):(sexp->bool)->bool`,
  mk_abs(`body:sexp`,
    mk_comb(`(??):(sexp->bool)->bool`,
      mk_abs(`arg:sexp`,
        subst [`body:sexp`,`Symbol "body"`; `arg:sexp`,`Symbol "arg"`]
                  `'((lambda (x) body) arg) = '((lambda (x) body) arg)`))));;

gg it;;
ee (GEN_LISPTERM_SLV `body:sexp`);;
ee (GEN_LISPTERM_SLV `arg:sexp`);;
ee REFL_SLV;;
take 10 (top_thms());;

(*
mk_comb(`(??):(sexp->bool)->bool`,
  mk_abs(`body:sexp`,
    mk_comb(`(??):(sexp->bool)->bool`,
      mk_abs(`arg:sexp`,
        subst [`body:sexp`,`Symbol "body"`; `arg:sexp`,`Symbol "arg"`]
*)

(*
'((lambda (x) (list x (list (quote quote) x)))
  (quote (lambda (x) (list x (list (quote quote) x)))))
*)

mk_comb(`(??):(sexp->bool)->bool`,
  mk_abs(`u:sexp`,
    mk_comb(`(??):(sexp->bool)->bool`,
      mk_abs(`w:sexp`,
        subst [`u:sexp`,`Symbol "u"`;`w:sexp`,`Symbol "w"`]
          `EVAL []
             '((lambda (x) (list x u))
               (quote (lambda (x) (list x (list (quote quote) x)))))
             '((lambda (x) (list x u))
               (quote (lambda (x) (list x (list (quote quote) x)))))`))));;
gg it;;

(*
gg        `EVAL [] '((lambda (x) (list x (list (quote quote) x)))
                     (quote (lambda (x) (list x (list (quote quote) x)))))
                    '((lambda (x) (list x (list (quote quote) x)))
                      (quote (lambda (x) (list x (list (quote quote) x)))))`;;
*)
ee (GEN_LISPTERM_SLV `u:sexp`);;
ee (GEN_LISPTERM_SLV `w:sexp`);;
time ee (PROLOG_SLV NO_CONV
     [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES; APPEND_HORN;
      RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
      EVAL_RULES]);;
take 1 (top_thms());;
