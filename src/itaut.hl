(* ========================================================================= *)
(* More about solvers.                                                       *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Solvers associated to tactics.                                            *)
(* ------------------------------------------------------------------------- *)

let UNIFY_ACCEPT_SLV th = SOLVER (fun mvs -> UNIFY_ACCEPT_TAC mvs th);;

(* ========================================================================= *)
(* ITAUT.                                                                    *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Rules.                                                                    *)
(* ------------------------------------------------------------------------- *)

let IMPLICATE t =
  let th1 = AP_THM NOT_DEF (dest_neg t) in
  CONV_RULE (RAND_CONV BETA_CONV) th1;;

(*
IMPLICATE (`~p`);;
|- ~p <=> p ==> F
*)

(* ------------------------------------------------------------------------- *)
(* Tactics and tacticals.                                                    *)
(* ------------------------------------------------------------------------- *)

let IMPLICATE_TAC : tactic =
  fun gl -> CONV_TAC(K(IMPLICATE(snd gl))) gl;;

let CONJUNCTS_THEN' ttac cth =
  ttac(CONJUNCT1 cth) THEN ttac(CONJUNCT2 cth);;

(* ------------------------------------------------------------------------- *)
(* Solvers associated to tactics.                                            *)
(* ------------------------------------------------------------------------- *)

let IMPLICATE_SLV = TACTIC_SLV IMPLICATE_TAC;;

(* ------------------------------------------------------------------------- *)
(* Reversible solvers.                                                       *)
(* ------------------------------------------------------------------------- *)

  let RIGHT_REVERSIBLE_TAC = FIRST
   [CONJ_TAC;                                                     (* and     *)
    GEN_TAC;                                                      (* forall  *)
    DISCH_TAC;                                                    (* implies *)
    IMPLICATE_TAC;                                                (* not     *)
    EQ_TAC];;                                                     (* iff     *)

  let LEFT_REVERSIBLE_TAC th gl = tryfind (fun ttac -> ttac th gl)
   [CONJUNCTS_THEN' ASSUME_TAC;                                   (* and    *)
    DISJ_CASES_TAC;                                               (* or     *)
    CHOOSE_TAC;                                                   (* exists *)
    (fun th -> ASSUME_TAC (EQ_MP (IMPLICATE (concl th)) th));     (* not    *)
    (CONJUNCTS_THEN' MP_TAC o uncurry CONJ o EQ_IMP_RULE)];;      (* iff    *)

  let RIGHT_REVERSIBLE_SLV = TACTIC_SLV RIGHT_REVERSIBLE_TAC
  and LEFT_REVERSIBLE_SLV : thm_solver = THM_TACTIC_SLV LEFT_REVERSIBLE_TAC;;

let META_SPEC_SLV : thm_solver =
  THM_TACTIC_SLV (fun th (asl,w as g) ->
    let gv = genvar(type_of(fst(dest_forall(concl th)))) in
    (ASSUME_TAC th THEN META_SPEC_TAC gv th) g);;

let DISJ_SLV : solver = ORELSE_SLV DISJ1_SLV DISJ2_SLV;;

let X_META_EXISTS_SLV : solver =
  TACTIC_SLV (fun asl,w as g ->
                let gv = genvar(type_of(fst(dest_exists w))) in
                X_META_EXISTS_TAC gv g);;

let ASM_ANT_TAC : thm_tactic =
  fun th -> SUBGOAL_THEN (fst(dest_imp(concl th)))
              (fun ath -> ASSUME_TAC (MP th ath));;

let ASM_ANT_SLV = THM_TACTIC_SLV ASM_ANT_TAC;;

(*
  let rec ITAUT_SLV n gl =
    report ("Deep: "^string_of_int n);
    let mvs,(asl,w) = gl in
    print_goal (asl,w);
    MPLUS_LIST_SLV
      [MPLUS_ASSUM_SLV UNIFY_ACCEPT_SLV;
       ACCEPT_SLV TRUTH;
       MPLUS_ASSUM_SLV CONTR_SLV;
       THEN_SLV RIGHT_REVERSIBLE_SLV (ITAUT_SLV (n+1));
       THEN_SLV (MPLUS_X_ASSUM_SLV LEFT_REVERSIBLE_SLV) (ITAUT_SLV (n+1));
       MPLUS_X_ASSUM_SLV(fun th ->
         EVERY_SLV [META_SPEC_SLV th; (ITAUT_SLV (n+1))]);
       THEN_SLV DISJ_SLV (ITAUT_SLV (n+1));
       THEN_SLV X_META_EXISTS_SLV (ITAUT_SLV (n+1));
       THEN_SLV (MPLUS_ASSUM_SLV ASM_ANT_SLV) (ITAUT_SLV (n+1))] gl;;

let ITAUT_SLV = ITAUT_SLV 0;;
*)

let ITAUT0_SLV =
  FIRST_SLV [ACCEPT_SLV TRUTH;
             FIRST_ASSUM_SLV UNIFY_ACCEPT_SLV;
             FIRST_ASSUM_SLV CONTR_SLV];;

let ITAUT1_SLV g =
  FIRST_SLV [RIGHT_REVERSIBLE_SLV;
             FIRST_X_ASSUM_SLV LEFT_REVERSIBLE_SLV;
             FIRST_X_ASSUM_SLV META_SPEC_SLV;
             DISJ_SLV;
             X_META_EXISTS_SLV;
             FIRST_X_ASSUM_SLV ASM_ANT_SLV] g);;

let rec ITAUT_SLV : solver =
  fun gl -> concatf (ITAUT0_SLV gl)
                    (fun () -> THEN_SLV ITAUT1_SLV ITAUT_SLV gl);;

let counter = ref 40;;

let ITAUT_SLV : solver =
  let rec ITAUT_SLV n gl =
    (* if !counter <= 0 then failwith "Stop" else *)
    counter := !counter - 1;
    report ("Counter "^string_of_int !counter);
    ((report ("Deep: "^string_of_int n);
      let mvs,(asl,w) = gl in print_goal (asl,w)));
    concatf (ITAUT0_SLV gl)
            (fun () -> THEN_SLV ITAUT1_SLV (ITAUT_SLV (n+1)) gl) in
  let ITAUT_SLV' n gl =
    let s = ITAUT_SLV n gl in
    (match s with
       Empty -> report "Fail!";
     | Cons ((_,gls,_),_) -> if gls = [] then report "Finished!");
    s in
  ITAUT_SLV' 0;;

let ITAUT_SLV : solver =
  let rec ITAUT_SLV n gl =
    report ("Deep: "^string_of_int n);
    concatf (ITAUT0_SLV gl)
            (fun () -> THEN_SLV ITAUT1_SLV (ITAUT_SLV (n+1)) gl) in
  let ITAUT_SLV' n gl =
    let s = ITAUT_SLV n gl in
    (match s with
       Empty -> report "Fail!";
     | Cons ((_,gls,_),_) -> if gls = [] then report "Finished!");
    s in
  ITAUT_SLV' 0;;

let gstate::_ = take 10 (ITAUT_SLV ([],([],`F ==> a`)));;
let gstate::_ = take 10 (ITAUT_SLV ([],([],`a /\ b ==> b /\ a`)));;
let gstate::_ = take 10 (ITAUT_SLV ([],([],`a ==> ~ ~ a`)));;
let [] = take 10 (ITAUT_SLV ([],([],`~ ~a ==> a`)));;
wrapup gstate;;

take 10 (stream_map wrapup (ITAUT_SLV ([`a:bool`],(["",ASSUME `F`],`a:bool`))));;

time TAUT
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F))
  ==> (output <=> ~(input_a \/ input_b))`;;

counter := 40;;
let gstate :: _ = time (take 1 o ITAUT_SLV)
([],([],
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F)) /\
  output
  ==> ~(input_a \/ input_b)`));;
wrapup gstate;;

counter := 100;;
let gstate :: _ = time (take 1 o ITAUT_SLV)
([],([],
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F)) /\
  ~input_a /\ ~input_b
  ==> output`));;
wrapup gstate;;

time (take 1 o ITAUT_SLV)
([],([],
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  ~input_a /\ ~input_b
  ==> output`));;

time (take 1 o ITAUT_SLV)
([],([],
 `(internal <=> T) /\
  (~input_b ==> (output <=> internal)) /\
  ~input_a /\ ~input_b
  ==> output`));;

time (take 1 o ITAUT_SLV)
([],([],
 `(~input_b ==> (output <=> internal)) /\
  (internal <=> T) /\
  ~input_a /\ ~input_b
  ==> output`));;

time (take 1 o ITAUT_SLV)
([],([],
 `(~input_a ==> (internal <=> T)) /\
  ~input_a
  ==> output`));;

time (take 1 o ITAUT_SLV)
([],([],
 `(~input_a ==> (internal <=> T)) /\
  (output <=> internal) /\
  ~input_a /\ ~input_b
  ==> output`));;

time (take 1 o ITAUT_SLV)
([],([],
 `(internal <=> T) /\
  (output <=> internal) /\
  ~input_a /\ ~input_b
  ==> output`));;

time (take 1 o ITAUT_SLV)
([],([],
 `(~input_a ==> (internal <=> T)) /\
  (~input_b ==> (output <=> internal)) /\
  (input_a ==> (output <=> F)) /\
  (input_b ==> (output <=> F))
  ==> (output <=> ~(input_a \/ input_b))`));;

time TAUT
`(i1 /\ i2 <=> a) /\
 (i1 /\ i3 <=> b) /\
 (i2 /\ i3 <=> c) /\
 (i1 /\ c <=> d) /\
 (m /\ r <=> e) /\
 (m /\ w <=> f) /\
 (n /\ w <=> g) /\
 (p /\ w <=> h) /\
 (q /\ w <=> i) /\
 (s /\ x <=> j) /\
 (t /\ x <=> k) /\
 (v /\ x <=> l) /\
 (i1 \/ i2 <=> m) /\
 (i1 \/ i3 <=> n) /\
 (i1 \/ q <=> p) /\
 (i2 \/ i3 <=> q) /\
 (i3 \/ a <=> r) /\
 (a \/ w <=> s) /\
 (b \/ w <=> t) /\
 (d \/ h <=> u) /\
 (c \/ w <=> v) /\
 (~e <=> w) /\
 (~u <=> x) /\
 (i \/ l <=> o1) /\
 (g \/ k <=> o2) /\
 (f \/ j <=> o3)
 ==> (o1 <=> ~i1) /\ (o2 <=> ~i2) /\ (o3 <=> ~i3)`;;

time (take 1 o ITAUT_SLV)
([],([],
 `(i1 /\ i2 <=> a) /\
 (i1 /\ i3 <=> b) /\
 (i2 /\ i3 <=> c) /\
 (i1 /\ c <=> d) /\
 (m /\ r <=> e) /\
 (m /\ w <=> f) /\
 (n /\ w <=> g) /\
 (p /\ w <=> h) /\
 (q /\ w <=> i) /\
 (s /\ x <=> j) /\
 (t /\ x <=> k) /\
 (v /\ x <=> l) /\
 (i1 \/ i2 <=> m) /\
 (i1 \/ i3 <=> n) /\
 (i1 \/ q <=> p) /\
 (i2 \/ i3 <=> q) /\
 (i3 \/ a <=> r) /\
 (a \/ w <=> s) /\
 (b \/ w <=> t) /\
 (d \/ h <=> u) /\
 (c \/ w <=> v) /\
 (~e <=> w) /\
 (~u <=> x) /\
 (i \/ l <=> o1) /\
 (g \/ k <=> o2) /\
 (f \/ j <=> o3)
 ==> (o1 <=> ~i1) /\ (o2 <=> ~i2) /\ (o3 <=> ~i3)`));;
