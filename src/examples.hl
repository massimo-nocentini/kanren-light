(* ------------------------------------------------------------------------- *)
(* Experiments with REFL_KTAC.                                               *)
(* ------------------------------------------------------------------------- *)

(* Example 1 *)
set_kanren_goal `META A B. [A;1;2] = [0;1;B]`;;
p();;
ke REFL_KTAC;;
ktop_thm();;

(* Same with TAC_KTAC REFL_TAC : Fails! *)
set_kanren_goal `META A B. [A;1;2] = [0;1;B]`;;
p();;
ke (TAC_KTAC REFL_TAC);;
ktop_thm();;

(* Example 2 *)
set_kanren_goal `META A B C. [A;C;2] = [0;A;B]`;;
p();;
ke REFL_KTAC;;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* How to break the invariant!                                               *)
(* ------------------------------------------------------------------------- *)

(*;;
set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke WRONG_KTAC;;
*)

(* ------------------------------------------------------------------------- *)
(* Our favorite example: angestor and all that...                            *)
(* ------------------------------------------------------------------------- *)

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

(* Fails! *)
set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC (fun tm -> TAC_KTAC (ACCEPT_TAC tm)));;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
let cg = !current_goalstack;;
p();;

(* -2 : funziona! *)
ke (TAC_KTAC (MATCH_MP_TAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`)));;

(* -1 : funziona! *)
current_goalstack := cg; p();;
ke (MP_KTAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`));;

(* 0 : funziona! *)
current_goalstack := cg; p();;
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC) (TAC_KTAC CONJ_TAC));;
ke (trace_ktactic "*" (FIRST_ASSUM_KTAC ACCEPT_KTAC));;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

(* 1 : funziona! *)
current_goalstack := cg; p();;
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
           (kthen_ (TAC_KTAC CONJ_TAC)
                   (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 2 : funziona! *)
kprove1
 (`META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (TAC_KTAC CONJ_TAC))
         (CUT_KTAC (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC))));;

kprove1
 (`META X:A.
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (TAC_KTAC CONJ_TAC))
         (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;

kprove1
 (`META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (TAC_KTAC CONJ_TAC))
         (CUT_KTAC (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;

(* 3 : funziona! *)
current_goalstack := cg; p();;
ke (kthenl_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                    (TAC_KTAC CONJ_TAC))
            [FIRST_ASSUM_KTAC ACCEPT_KTAC;
             FIRST_ASSUM_KTAC ACCEPT_KTAC]);;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* Tentativi ingenui di creare una tattica prolog.  Non può funzionare in    *)
(* maniera così semplice perché manca la struttura per implementare il       *)
(* backtrack.                                                                *)
(* ------------------------------------------------------------------------- *)

let FIND_KTAC:ktactic =
  KREPEAT
    (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
              (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                      (TAC_KTAC (REPEAT CONJ_TAC))));;

(* Pb: Introdurre una meta implicazione?! *)
(* Questo codice assume che l'implicazione non occorra nei goal. *)
let APPLY_KTAC:thm_ktactic =
  fun th -> try MP_KTAC th with Failure _ -> ACCEPT_KTAC th;;

let PROLOG_KTAC:ktactic =
  KREPEAT
    (kthen_ (FIRST_ASSUM_KTAC APPLY_KTAC)
            (TAC_KTAC (REPEAT CONJ_TAC)));;

set_kanren_goal
  `(!X Y Z:A. l X Y /\ q Y Z ==> q X Z) AND
   (!X:A. q X X) AND
   (!X Y. l X Y ==> l Y X) AND
   l d e AND l a c AND l a d AND l d c AND l b c
   ENTAILS
   q a b`;;
let cg = !current_goalstack;;
p();;

(* Loop!! *)
(*;;
ke PROLOG_KTAC;;
*)

current_goalstack := cg; p();;
ke FIND_KTAC;;
ktop_thm();;

current_goalstack := cg; p();;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (REPLICATE_KTAC 8
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (TAC_KTAC (REPEAT CONJ_TAC)))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (KREPEAT
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (TAC_KTAC (REPEAT CONJ_TAC)))));;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* Example without axioms.                                                   *)
(* ------------------------------------------------------------------------- *)

(*
needs "Library/rstc.ml";;

let PARENT_RULES,PARENT_INDUCT,PARENT_CASES = new_inductive_definition
  `PARENT 3 1 /\
   PARENT 42 3`;;

let PARENT_1,PARENT_2 = CONJ_PAIR PARENT_RULES;;

set_kanren_goal
  `META X:num. RTC PARENT 42 X`;;
ke(MP_KTAC (ISPEC `PARENT` RTC_TRANS));;
ke (TAC_KTAC CONJ_TAC);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_2);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_1);;
top_thm();;
*)


(* ------------------------------------------------------------------------- *)
(* New set of examples with Choice.                                          *)
(* ------------------------------------------------------------------------- *)

let even_tm = `EVEN`;;
let EVEN_RULE n =
  EQT_ELIM (NUM_EVEN_CONV (mk_comb(even_tm, mk_numeral n)));;

let rec even_ktac n g =
  (korelse_ (ACCEPT_KTAC (EVEN_RULE n)) (even_ktac (n +/ Int 2))) g;;

let EVEN_KTAC : ktactic = even_ktac num_0;;

let EVEN0,EVEN2 = CONJ_PAIR (ARITH_RULE `EVEN 0 /\ EVEN 2`);;

set_kanren_goal `META X. EVEN X`;;
let myk = ref (fun () -> hd(!current_goalstack));;
let k = 
try
ke (korelse_ (ACCEPT_KTAC EVEN0) (ACCEPT_KTAC EVEN2))
with Choice (_, k) -> (myk := k; fail());;

!myk ();;
current_goalstack := [it];;
ktop_thm();;

kprove1(`META X. EVEN X`,
  korelse_ (ACCEPT_KTAC EVEN0) (ACCEPT_KTAC EVEN2));;

kprove1(`META X. EVEN X`,
  DROP_KTAC 0 (korelse_ (ACCEPT_KTAC EVEN0) (ACCEPT_KTAC EVEN2)));;

kprove1(`META X. EVEN X`,
  DROP_KTAC 10 EVEN_KTAC);;

kprove1(`META X. EVEN X /\ 3 <= X`,
  kthenl_ (TAC_KTAC CONJ_TAC)
          [EVEN_KTAC;
           ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;

kprove1(`META X. EVEN X /\ 3 <= X`,
  kthenl_ (TAC_KTAC CONJ_TAC)
          [ACCEPT_KTAC (ARITH_RULE `EVEN 4`);
           ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;

kprove1(`META X. EVEN X /\ 3 <= X`,
  kthenl_ (TAC_KTAC CONJ_TAC)
          [korelse_ (ACCEPT_KTAC (ARITH_RULE `EVEN 2`))
                    (ACCEPT_KTAC (ARITH_RULE `EVEN 4`));
           ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;

set_kanren_goal `META X. EVEN X /\ 3 <= X`;;
ke (kthenl_ (TAC_KTAC CONJ_TAC)
            [korelse_ (ACCEPT_KTAC (ARITH_RULE `EVEN 2`))
                      (ACCEPT_KTAC (ARITH_RULE `EVEN 4`));
             ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;


try
fail()
with Choice (g,_) -> current_goalstack := [g];;
ktop_thm();;
