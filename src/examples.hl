(* ------------------------------------------------------------------------- *)
(* Tools.                                                                    *)
(* ------------------------------------------------------------------------- *)

let do_fail f x =
  if (try f x; false with Failure _ -> true)
  then report "do_fail: Ok, it fails."
  else failwith "do_fail: Do not fail.";;

let ke1 (ktac:ktactic) : goalstack = refine(kby1(KVALID ktac));;

(* ------------------------------------------------------------------------- *)
(* Experiments with REFL_KTAC.                                               *)
(* ------------------------------------------------------------------------- *)

(* Example 1 *)
kg `META A B. [A;1;2] = [0;1;B]`;;
ke REFL_KTAC;;
ktop_thm();;

(* Composizione finale di verifica. *)
kprove1(`META A B. [A;1;2] = [0;1;B]`, REFL_KTAC);;

(* Same with TAC_KTAC REFL_TAC : Fails! *)
kg `META A B. [A;1;2] = [0;1;B]`;;
do_fail ke (TAC_KTAC REFL_TAC);;

(* Example 2 : use of sharing. *)
kg `META A B C. [A;C;2] = [0;A;B]`;;
ke REFL_KTAC;;
ktop_thm();;

(* Composizione finale di verifica. *)
kprove1(`META A B C. [A;C;2] = [0;A;B]`,REFL_KTAC);;

(* ------------------------------------------------------------------------- *)
(* How to break the invariant!                                               *)
(* Test for KVALID.                                                          *)
(* ------------------------------------------------------------------------- *)

kg `META X:A.
      (!Y:A. ancestor Y pluto)
      ENTAILS
      ancestor pippo X`;;
do_fail ke WRONG_KTAC;;

(* ------------------------------------------------------------------------- *)
(* Our favorite example: angestor and all that...                            *)
(* ------------------------------------------------------------------------- *)

kg `META X:A.
      (!Y:A. ancestor Y pluto)
      ENTAILS
      ancestor pippo X`;;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

kprove1
 (`META X:A.
      (!Y:A. ancestor Y pluto)
      ENTAILS
      ancestor pippo X`,
  FIRST_ASSUM_KTAC ACCEPT_KTAC);;

(* Fails! (ACCEPT_TAC do not use unification.) *)
kg `META X:A.
      (!Y:A. ancestor Y pluto)
      ENTAILS
      ancestor pippo X`;;
do_fail ke (FIRST_ASSUM_KTAC (fun tm -> TAC_KTAC (ACCEPT_TAC tm)));;

kg `META X:A.
      (!X. ancestor X X) AND
      (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
      ancestor pippo pluto AND
      ancestor pluto paperino
      ENTAILS
      ancestor pippo X`;;
let cg = !current_goalstack;;

(* -2 : funziona! Non crea meta. *)
ke (TAC_KTAC (MATCH_MP_TAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`)));;

(* -1 : funziona! Crea una nuova meta per Y. *)
current_goalstack := cg; p();;
ke (MP_KTAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`));;

(* -7/8 : funziona! Test di kthen_*)
current_goalstack := cg; p();;
ke (FIRST_ASSUM_KTAC MP_KTAC);;

(* -3/4 : funziona! Test di kthen_*)
current_goalstack := cg; p();;
ke1 (FIRST_ASSUM_KTAC MP_KTAC);;

(* -1/2 : funziona! Test di kthen_*)
current_goalstack := cg; p();;
ke (CUT_KTAC (FIRST_ASSUM_KTAC MP_KTAC));;

(* -1/4 : funziona! Test di kthen_*)
current_goalstack := cg; p();;
try ke (FIRST_ASSUM_KTAC MP_KTAC); failwith "Should not reach this point" with
  Choice (gs, ktac) -> (current_goalstack := cg; ke ktac);;

(* 0 : funziona! Test di kthen_*)
current_goalstack := cg; p();;
ke1 (kthen_ (FIRST_ASSUM_KTAC MP_KTAC) (TAC_KTAC CONJ_TAC));;
ke1 (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ke1 (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

kprove1
 (`META X:A.
      (!X. ancestor X X) AND
      (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
      ancestor pippo pluto AND
      ancestor pluto paperino
      ENTAILS
      ancestor pippo X`,
  kthenl_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC) (TAC_KTAC CONJ_TAC))
          [trace_ktactic "*" (FIRST_ASSUM_KTAC ACCEPT_KTAC);
           FIRST_ASSUM_KTAC ACCEPT_KTAC]);;

(* 1/4 : Ok, dà MK_KTAC: Wrong theorem *)
current_goalstack := cg; p();;
try ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
               (TAC_KTAC CONJ_TAC));
    failwith "Should not reach this point"
with Choice (_, ktac) -> (current_goalstack := cg; ke ktac);;

(* 1/2 : Dovrebbe dare MK_KTAC: Wrong theorem *)
current_goalstack := cg; p();;
try ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
               (kthen_ (TAC_KTAC CONJ_TAC)
                       (CUT_KTAC (FIRST_ASSUM_KTAC ACCEPT_KTAC))));
    failwith "Should not reach this point"
with Choice (_, ktac) -> (current_goalstack := cg; ke ktac);;

(* 1 : funziona! *)
current_goalstack := cg; p();;
ke1 (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
            (kthen_ (TAC_KTAC CONJ_TAC)
                    (CUT_KTAC (FIRST_ASSUM_KTAC ACCEPT_KTAC))));;
ktop_thm();;

current_goalstack := cg; p();;
ke1 (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
            (kthen_ (TAC_KTAC CONJ_TAC)
                    (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 2 : funziona! *)
kprove1
 (`META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (TAC_KTAC CONJ_TAC))
         (CUT_KTAC (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC))));;

(* NON FUNZIONA! Generated wrong theorem. *)

kprove1
 (`META X:A.
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (TAC_KTAC CONJ_TAC))
         (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;

kprove1
 (`META X:A.
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
         (kthen_ (TAC_KTAC CONJ_TAC)
                 (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC))));;

kprove1
 (`META X.
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor 1 2 AND
     ancestor 2 3
     ENTAILS
     ancestor 1 X`,
  kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
         (kthen_ (TAC_KTAC CONJ_TAC)
                 (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC))));;

kprove1
 (`META X:A.
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthenl_ (FIRST_ASSUM_KTAC MP_KTAC)
          [kthenl_ (TAC_KTAC CONJ_TAC)
                   [trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)]]);;

kg `META X:A.
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
ke1 (kthenl_ (FIRST_ASSUM_KTAC MP_KTAC)
          [kthenl_ (TAC_KTAC CONJ_TAC)
                   [trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)]]);;
ktop_thm();;

(* 3 : Sembra funzionare, ma non funziona, ktop_thm non fa il check di
   consistenza che invece fa kprove. *)
current_goalstack := cg; p();;
ke1 (kthenl_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC CONJ_TAC))
            [FIRST_ASSUM_KTAC ACCEPT_KTAC;
             FIRST_ASSUM_KTAC ACCEPT_KTAC]);;
ktop_thm();;

(* ========================================================================= *)
(* HIC SUNT LEONES!!                                                         *)
(* ========================================================================= *)


(* ------------------------------------------------------------------------- *)
(* Tentativi ingenui di creare una tattica prolog.  Non può funzionare in    *)
(* maniera così semplice perché manca la struttura per implementare il       *)
(* backtrack.                                                                *)
(* ------------------------------------------------------------------------- *)

let FIND_KTAC:ktactic =
  KREPEAT
    (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
              (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                      (TAC_KTAC (REPEAT CONJ_TAC))));;

(* Pb: Introdurre una meta implicazione?! *)
(* Questo codice assume che l'implicazione non occorra nei goal. *)
let APPLY_KTAC:thm_ktactic =
  fun th -> try MP_KTAC th with Failure _ -> ACCEPT_KTAC th;;

let PROLOG_KTAC:ktactic =
  KREPEAT
    (kthen_ (FIRST_ASSUM_KTAC APPLY_KTAC)
            (TAC_KTAC (REPEAT CONJ_TAC)));;

kg
  `(!X Y Z:A. l X Y /\ q Y Z ==> q X Z) AND
   (!X:A. q X X) AND
   (!X Y. l X Y ==> l Y X) AND
   l d e AND l a c AND l a d AND l d c AND l b c
   ENTAILS
   q a b`;;
let cg = !current_goalstack;;
p();;

(* Loop!! *)
(*;;
ke PROLOG_KTAC;;
*)

current_goalstack := cg; p();;
ke FIND_KTAC;;
ktop_thm();;

current_goalstack := cg; p();;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (REPLICATE_KTAC 8
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (TAC_KTAC (REPEAT CONJ_TAC)))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (KREPEAT
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (TAC_KTAC (REPEAT CONJ_TAC)))));;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* Example without axioms.                                                   *)
(* ------------------------------------------------------------------------- *)

(*
needs "Library/rstc.ml";;

let PARENT_RULES,PARENT_INDUCT,PARENT_CASES = new_inductive_definition
  `PARENT 3 1 /\
   PARENT 42 3`;;

let PARENT_1,PARENT_2 = CONJ_PAIR PARENT_RULES;;

kg
  `META X:num. RTC PARENT 42 X`;;
ke(MP_KTAC (ISPEC `PARENT` RTC_TRANS));;
ke (TAC_KTAC CONJ_TAC);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_2);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_1);;
top_thm();;
*)


(* ------------------------------------------------------------------------- *)
(* New set of examples with Choice.                                          *)
(* ------------------------------------------------------------------------- *)

let even_tm = `EVEN`;;
let EVEN_RULE n =
  EQT_ELIM (NUM_EVEN_CONV (mk_comb(even_tm, mk_numeral n)));;

let rec even_ktac n g =
  (korelse_ (ACCEPT_KTAC (EVEN_RULE n)) (even_ktac (n +/ Int 2))) g;;

let EVEN_KTAC : ktactic = even_ktac num_0;;

let EVEN0,EVEN2 = CONJ_PAIR (ARITH_RULE `EVEN 0 /\ EVEN 2`);;

kg `META X. EVEN X`;;
let myk = ref (fun () -> hd(!current_goalstack));;
let k = 
try
ke (korelse_ (ACCEPT_KTAC EVEN0) (ACCEPT_KTAC EVEN2))
with Choice (_, k) -> (myk := k; fail());;

!myk ();;
current_goalstack := [it];;
ktop_thm();;

kprove1(`META X. EVEN X`,
  korelse_ (ACCEPT_KTAC EVEN0) (ACCEPT_KTAC EVEN2));;

kprove1(`META X. EVEN X`,
  DROP_KTAC 0 (korelse_ (ACCEPT_KTAC EVEN0) (ACCEPT_KTAC EVEN2)));;

kprove1(`META X. EVEN X`,
  DROP_KTAC 10 EVEN_KTAC);;

kprove1(`META X. EVEN X /\ 3 <= X`,
  kthenl_ (TAC_KTAC CONJ_TAC)
          [EVEN_KTAC;
           ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;

kprove1(`META X. EVEN X /\ 3 <= X`,
  kthenl_ (TAC_KTAC CONJ_TAC)
          [ACCEPT_KTAC (ARITH_RULE `EVEN 4`);
           ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;

kprove1(`META X. EVEN X /\ 3 <= X`,
  kthenl_ (TAC_KTAC CONJ_TAC)
          [korelse_ (ACCEPT_KTAC (ARITH_RULE `EVEN 2`))
                    (ACCEPT_KTAC (ARITH_RULE `EVEN 4`));
           ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;

kg `META X. EVEN X /\ 3 <= X`;;
ke (kthenl_ (TAC_KTAC CONJ_TAC)
            [korelse_ (ACCEPT_KTAC (ARITH_RULE `EVEN 2`))
                      (ACCEPT_KTAC (ARITH_RULE `EVEN 4`));
             ACCEPT_KTAC (ARITH_RULE `3 <= 4`)]);;


try
fail()
with Choice (g,_) -> current_goalstack := [g];;
ktop_thm();;
