(* ------------------------------------------------------------------------- *)
(* Experiments with REFL_KTAC.                                               *)
(* ------------------------------------------------------------------------- *)

(* Example 1 *)
set_kanren_goal `META A B. [A;1;2] = [0;1;B]`;;
p();;
ke REFL_KTAC;;
ktop_thm();;

(* Same with TAC_KTAC REFL_TAC : Fails! *)
set_kanren_goal `META A B. [A;1;2] = [0;1;B]`;;
p();;
ke (TAC_KTAC REFL_TAC);;
ktop_thm();;

(* Example 2 *)
set_kanren_goal `META A B C. [A;C;2] = [0;A;B]`;;
p();;
ke REFL_KTAC;;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* How to break the invariant!                                               *)
(* ------------------------------------------------------------------------- *)

(*;;
set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke WRONG_KTAC;;
*)

(* ------------------------------------------------------------------------- *)
(* Our favorite example: angestor and all that...                            *)
(* ------------------------------------------------------------------------- *)

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC (fun tm -> TAC_KTAC (ACCEPT_TAC tm)));;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
let cg = !current_goalstack;;
p();;

(* -2 : funziona! *)
ke (TAC_KTAC (MATCH_MP_TAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`)));;

(* -1 : funziona! *)
current_goalstack := cg; p();;
ke (MP_KTAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`));;

(* 0 : funziona! *)
current_goalstack := cg; p();;
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC) (TAC_KTAC CONJ_TAC));;
ke (trace_ktactic "*" (FIRST_ASSUM_KTAC ACCEPT_KTAC));;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

(* 1 : funziona! *)
current_goalstack := cg; p();;
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
           (kthen_ (TAC_KTAC CONJ_TAC)
                   (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 2 : funziona! *)
kprove
 (`META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (TAC_KTAC CONJ_TAC))
         (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;

(* 3 : funziona! *)
current_goalstack := cg; p();;
ke (kthenl_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                    (TAC_KTAC CONJ_TAC))
            [FIRST_ASSUM_KTAC ACCEPT_KTAC;
             FIRST_ASSUM_KTAC ACCEPT_KTAC]);;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* Tentativi ingenui di creare una tattica prolog.  Non può funzionare in    *)
(* maniera così semplice perché manca la struttura per implementare il       *)
(* backtrack.                                                                *)
(* ------------------------------------------------------------------------- *)

let FIND_KTAC:ktactic =
  KREPEAT
    (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
              (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                      (TAC_KTAC (REPEAT CONJ_TAC))));;

(* Pb: Introdurre una meta implicazione?! *)
(* Questo codice assume che l'implicazione non occorra nei goal. *)
let APPLY_KTAC:thm_ktactic =
  fun th -> try MP_KTAC th with Failure _ -> ACCEPT_KTAC th;;

let PROLOG_KTAC:ktactic =
  KREPEAT
    (kthen_ (FIRST_ASSUM_KTAC APPLY_KTAC)
            (TAC_KTAC (REPEAT CONJ_TAC)));;

set_kanren_goal
  `(!X Y Z:A. l X Y /\ q Y Z ==> q X Z) AND
   (!X:A. q X X) AND
   (!X Y. l X Y ==> l Y X) AND
   l d e AND l a c AND l a d AND l d c AND l b c
   ENTAILS
   q a b`;;
let cg = !current_goalstack;;
p();;

(* Loop!! *)
(*;;
ke PROLOG_KTAC;;
*)

current_goalstack := cg; p();;
ke FIND_KTAC;;
ktop_thm();;

current_goalstack := cg; p();;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (TAC_KTAC (REPEAT CONJ_TAC))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (REPLICATE_KTAC 8
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (TAC_KTAC (REPEAT CONJ_TAC)))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (KREPEAT
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (TAC_KTAC (REPEAT CONJ_TAC)))));;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* Example without axioms.                                                   *)
(* ------------------------------------------------------------------------- *)

(*
needs "Library/rstc.ml";;

let PARENT_RULES,PARENT_INDUCT,PARENT_CASES = new_inductive_definition
  `PARENT 3 1 /\
   PARENT 42 3`;;

let PARENT_1,PARENT_2 = CONJ_PAIR PARENT_RULES;;

set_kanren_goal
  `META X:num. RTC PARENT 42 X`;;
ke(MP_KTAC (ISPEC `PARENT` RTC_TRANS));;
ke (TAC_KTAC CONJ_TAC);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_2);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_1);;
top_thm();;
*)
