(* ========================================================================= *)
(* Adapt the HOL Light tactic mechanism to a Kanren-like framework.          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* top_thm done right!                                                       *)
(* ------------------------------------------------------------------------- *)

let ktop_thm() =
  let ((_,inst),[],f)::_ = !current_goalstack in
  f inst [];;

(* ------------------------------------------------------------------------- *)
(* Meta goals.                                                               *)
(* ------------------------------------------------------------------------- *)

parse_as_binder "META";;
parse_as_infix ("ENTAILS",(0,"right"));;
parse_as_infix ("AND",(1,"right"));;

let META = new_definition `(META) = (?)`;;
let ENTAILS = new_definition `(ENTAILS) = (==>)`;;
let MAND = new_definition `(AND) = (/\)`;;

let is_meta = is_binder "META";;
let dest_meta = dest_binder "META";;
let strip_meta = splitlist dest_meta;;

let is_mand = is_binary "AND";;
let dest_mand = dest_binary "AND";;
let split_mand = striplist dest_mand;;

let is_entails = is_binary "ENTAILS";;
let dest_entails = dest_binary "ENTAILS";;

let dest_kanren_goal tm =
  let mvars,rtm = strip_meta tm in
  try let btm,htm = dest_entails rtm in
      mvars,(rev(split_mand btm),htm)
  with Failure _ -> mvars,([],rtm);;

(* Example *)
(*
dest_kanren_goal
  `META X.
     X = 5 ==> fives X AND
     fives X ==> fives X
     ENTAILS
     fives X`;;
*)

let set_kanren_goal =
  let propagate_thm i [th] = INSTANTIATE_ALL i th in
  fun tm ->
    let mvars,(tml,w) = dest_kanren_goal tm in
    let asl = map (fun th -> "",ASSUME th) tml in
    current_goalstack := [(mvars,null_inst),[asl,w],propagate_thm];;

(* ------------------------------------------------------------------------- *)
(* Generalized, Kanren-like tactics.                                         *)
(* ------------------------------------------------------------------------- *)

type kgoal = term list* goal;;

type ktactic = kgoal -> goalstate;;

type thm_ktactic = thm -> ktactic;;

(* ------------------------------------------------------------------------- *)
(* Debug tools.                                                              *)
(* ------------------------------------------------------------------------- *)

let trace_justification : string -> justification -> justification =
  fun s just ((_,alist,_) as inst) ths ->
    Format.print_string ("trace_justification "^s);
    Format.print_string ": ";
    do_list (fun (tm,v) -> print_qterm tm;
                           Format.print_string " <- ";
                           print_qterm v;
                           Format.print_string ", ")
            alist;
    Format.print_newline();
    do_list (fun th -> print_thm th; Format.print_newline()) ths;
    try just inst ths with
      Failure _ -> failwith "trace_justification: justification failed";;

let trace_ktactic msg ktac (mvs,g) =
  Format.print_string "trace_ktactic ";
  Format.print_string msg;
  Format.print_string ":\nMetas: ";
  do_list (fun tm -> print_qterm tm; Format.print_string ", ") mvs;
  Format.print_string "\nGoal:\n";
  print_goal g;
  Format.print_newline();
  ktac (mvs,g);;

(* ------------------------------------------------------------------------- *)
(* Basic tactics.                                                            *)
(* ------------------------------------------------------------------------- *)

let fresh_thm th =
  let vars,bth = splitlist SPEC_VAR th in
  let vars' = map (genvar o snd o dest_var) vars in
  let bth' = INST (zip vars' vars) bth in
  GENL vars' bth';;

(* Test *)
g `x = 1 ==> !x y. x + y = y + x`;;
e ARITH_TAC;;
let th = UNDISCH (top_thm());;
fresh_thm th;;

let propagate_mp rth i [th] =
  Format.print_string "propagate_mp:\n";
  print_thm rth; Format.print_newline();
  print_thm (INSTANTIATE_ALL i rth); Format.print_newline();
  MP (INSTANTIATE_ALL i rth) th;;

let (MP_KTAC : thm -> ktactic) =
  fun th ->
    let th = fresh_thm th in
    let avs,tm = strip_forall(concl th) in
    let btm,htm = dest_imp tm in
    fun mvs,(asl,w) ->
      let mvs' = union avs mvs in
      let inst1 = term_unify mvs' w htm in
      let asl' = map (fun s,th -> s,INSTANTIATE inst1 th) asl in
      let gl = asl',instantiate inst1 btm in
      let th' = SPEC_ALL (INSTANTIATE_ALL inst1 th) in
      (mvs',inst1),[gl],propagate_mp th';;

let ACCEPT_KTAC : thm_ktactic =
  let propagate_thm th i [] = INSTANTIATE_ALL i th in
  fun th ->
    let th = fresh_thm th in
    let avs = fst (strip_forall (concl th))
    and th = SPEC_ALL th in
    fun (mvs,(asl,w)) ->
      let insts = term_unify (union avs mvs) (concl th) w in
      let th' = INSTANTIATE insts th in
      let insts' = term_unify mvs (concl th') w in
      ([],insts'),[],propagate_thm th';;

(* ------------------------------------------------------------------------- *)
(* Tactic composition.                                                       *)
(* ------------------------------------------------------------------------- *)

let propagate_empty (i:instantiation) ([]:thm list) : thm list = [];;

let (inst_kgoal:instantiation->kgoal->kgoal) =
  fun p (mvs,g) -> mvs,inst_goal p g;;

let compose_justs
    (n:int)
    (just1:justification)
    (just2:instantiation -> thm list -> thm list)
    (i:instantiation)
    (ths:thm list)
    : thm list =
  let ths1,ths2 = chop_list n ths in
  (just1 i ths1)::(just2 i ths2);;

(* Il valore di ritorno di seqapply e "quasi" un goalstate ma la terza
   componente e' una justification "multipla" *)

let rec seqapply (l1:ktactic list) (l2:kgoal list)
          : (term list * instantiation) * goal list *
            (instantiation -> thm list -> thm list) =
 match (l1,l2) with
   ([],[]) -> null_meta,[],propagate_empty
 | ((ktac:ktactic)::ktacs),((kgoal:kgoal)::kgoals) ->
          let ((mvs1,insts1),gls1,just1) = ktac kgoal in
          let kgoals' = map (inst_kgoal insts1) kgoals in
          let ((mvs2,insts2),gls2,just2) = seqapply ktacs kgoals' in
          ((union mvs1 mvs2,compose_insts insts1 insts2),
           gls1@gls2,compose_justs (length gls1) just1 just2)
 | _,_ -> failwith "seqapply: Length mismatch";;

let justsequence
    (just1:justification)
    (just2:instantiation -> thm list -> thm list)
    (insts2:instantiation)
    : justification =
  fun i ths -> just1 (compose_insts insts2 i) (just2 i ths);;

let (ktacsequence : goalstate -> ktactic list -> goalstate) =
  fun ((mvs1,insts1),gls1,just1) ktacl ->
    let ((mvs2,insts2),gls2,just2) =
      seqapply ktacl (map (fun g -> mvs1,g) gls1) in
    let just = justsequence just1 just2 insts2 in
    ((union mvs1 mvs2,compose_insts insts1 insts2),gls2,just);;

let (kthenl_: ktactic -> ktactic list -> ktactic) =
  fun ktac1 ktac2l g -> ktacsequence (ktac1 g) ktac2l;;

let (kthen_: ktactic -> ktactic -> ktactic) =
  fun ktac1 ktac2 g ->
    let _,gls,_ as gstate = ktac1 g in
    ktacsequence gstate (replicate ktac2 (length gls));;

(*
let (THEN),(THENL) =
  then_,thenl_;;
*)

(* ------------------------------------------------------------------------- *)
(* Fail/resume reasoning patterns.                                           *)
(* ------------------------------------------------------------------------- *)

let (korelse_: ktactic -> ktactic -> ktactic) =
  fun ktac1 ktac2 g ->
    try ktac1 g with Failure _ -> ktac2 g;;

let (FAIL_KTAC: string -> ktactic) =
  fun tok g -> failwith tok;;

let (NO_KTAC: ktactic) =
  FAIL_KTAC "NO_KTAC";;

let (ALL_KTAC:ktactic) =
  fun (mvs,g) -> (mvs,null_inst),[g],fun _ [th] -> th;;

let KTRY ktac =
  korelse_ ktac ALL_KTAC;;

let rec KREPEAT ktac =
  korelse_ (kthen_ ktac (KREPEAT ktac)) ALL_KTAC;;

let KEVERY ktacl =
  itlist kthen_ ktacl ALL_KTAC;;

let (KFIRST: ktactic list -> ktactic) =
  end_itlist korelse_;;

let MAP_KEVERY ktacf lst =
  KEVERY (mapfilter ktacf lst);;

let MAP_KFIRST ktacf lst =
  KFIRST (mapfilter ktacf lst);;

let (CHANGED_KTAC: ktactic -> ktactic) =
  fun ktac (mvs,g) as gs ->
    let (meta,gl,_ as gstate) = ktac gs in
    if meta = null_meta && length gl = 1 && hd gl = g
    then failwith "CHANGED_KTAC" else gstate;;

let rec REPLICATE_KTAC n ktac =
  if n <= 0 then ALL_KTAC else kthen_ ktac (REPLICATE_KTAC (n - 1) ktac);;

(* ------------------------------------------------------------------------- *)
(* Higher-order tactics and tacticals.                                       *)
(* ------------------------------------------------------------------------- *)

let (FIRST_ASSUM_KTAC: thm_ktactic -> ktactic) =
  fun ktac (mvs,(asl,w)) as kg ->
    try MAP_KFIRST (fun (_,th) -> ktac th) asl kg with
      Failure _ -> failwith "pippo";;

(* ------------------------------------------------------------------------- *)
(* Interactive use of tactics.                                               *)
(* ------------------------------------------------------------------------- *)

(* Con propagazione "ridotta" dell'instanziazione. *)
let (kby:ktactic->refinement) =
  fun ktac ((mvs,inst),gls,just) ->
    if gls = [] then failwith "No goal set" else
    let g = hd gls
    and ogls = tl gls in
    let ((newmvs,newinst),subgls,subjust) = ktac (mvs,g) in
    let n = length subgls in
    let mvs' = union newmvs mvs
    and inst' = compose_insts inst newinst
    and gls' = subgls @ map (inst_goal newinst) ogls in
    let just' i ths =
      let cths,oths = chop_list n ths in
      let sths = subjust i cths :: oths in
      just i sths in
    (mvs',inst'),gls',just';;

let ke ktac = refine(kby ktac);;

let ktactic_of_tactic (tac:tactic) : ktactic =
  fun (mvs,g) ->
    let ((mvs',inst),gls,just) = tac g in
    ((union mvs mvs',inst),gls,just);;

(* ------------------------------------------------------------------------- *)
(* Our favorite example.                                                     *)
(* ------------------------------------------------------------------------- *)

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
p();;
ke (FIRST_ASSUM_KTAC MP_KTAC);;
ke (ktactic_of_tactic CONJ_TAC);;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

(*
let (KTAC_PROOF : kgoal * ktactic -> thm) =
  fun (g,tac) ->
    let gstate = mk_kgoalstate g in
    let _,sgs,just = kby tac gstate in
    if sgs = [] then just null_inst []
    else failwith "KTAC_PROOF: Unsolved goals";;

let kprove(t,ktac) =
  let th = KTAC_PROOF(([],t),ktac) in
  let t' = concl th in
  if t' = t then th else
  try EQ_MP (ALPHA t' t) th
  with Failure _ -> failwith "kprove: justification generated wrong theorem";;
*)

(* ------------------------------------------------------------------------- *)
(* Example without axioms.                                                   *)
(* ------------------------------------------------------------------------- *)

(*
needs "Library/rstc.ml";;

let PARENT_RULES,PARENT_INDUCT,PARENT_CASES = new_inductive_definition
  `PARENT 3 1 /\
   PARENT 42 3`;;

let PARENT_1,PARENT_2 = CONJ_PAIR PARENT_RULES;;

set_kanren_goal
  `META X:num. RTC PARENT 42 X`;;
ke(MP_KTAC (ISPEC `PARENT` RTC_TRANS));;
ke (ktactic_of_tactic CONJ_TAC);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_2);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_1);;
top_thm();;
*)


(* ------------------------------------------------------------------------- *)

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
let cg = !current_goalstack;;
p();;

(* 0 : funziona! *)
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC) (ktactic_of_tactic CONJ_TAC));;
ke (trace_ktactic "*" (FIRST_ASSUM_KTAC ACCEPT_KTAC));;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

(* 1 : funziona! *)
current_goalstack := cg; p();;
ke (kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                    (ktactic_of_tactic CONJ_TAC))
           (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 2 : error tryfind *)
current_goalstack := cg; p();;
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
           (kthen_ (ktactic_of_tactic CONJ_TAC)
                   (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 3 : error tryfind *)
current_goalstack := cg; p();;
ke (trace_ktactic "1" (FIRST_ASSUM_KTAC MP_KTAC));;
ke (kthen_ (trace_ktactic "2" (ktactic_of_tactic CONJ_TAC))
           (trace_ktactic "3" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 4 : funziona! *)
current_goalstack := cg; p();;
ke (kthenl_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                    (ktactic_of_tactic CONJ_TAC))
            [FIRST_ASSUM_KTAC ACCEPT_KTAC;
             FIRST_ASSUM_KTAC ACCEPT_KTAC]);;
ktop_thm();;

(* ------------------------------------------------------------------------- *)

let FIND_KTAC:ktactic =
  let rec find g =
    (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
              (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                      (kthen_ (ktactic_of_tactic (REPEAT CONJ_TAC))
                              find))) g in
  find;;

(* Pb: Introdurre una meta implicazione?! *)
(* Questo codice assume che l'implicazione non occorra nei goal. *)
let APPLY_KTAC:thm_ktactic =
  fun th -> try MP_KTAC th with Failure _ -> ACCEPT_KTAC th;;

let PROLOG_KTAC:ktactic =
  let rec prolog g =
    kthen_ (FIRST_ASSUM_KTAC APPLY_KTAC)
           (kthen_ (ktactic_of_tactic (REPEAT CONJ_TAC)) prolog)
           g in
  prolog;;

set_kanren_goal
  `(!X Y Z:A. l X Y /\ q Y Z ==> q X Z) AND
   (!X:A. q X X) AND
   (!X Y. l X Y ==> l Y X) AND
   l d e AND l a c AND l a d AND l d c AND l b c
   ENTAILS
   q a b`;;
p();;
ke PROLOG_KTAC;;
ke FIND_KTAC;;
ktop_thm();;

(*
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ktop_thm();;
*)

(* ------------------------------------------------------------------------- *)

(*;;
META_SPEC_TAC
X_META_EXISTS_TAC
*)