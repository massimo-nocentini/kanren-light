(* ========================================================================= *)
(* Adapt the HOL Light tactic mechanism to a Kanren-like framework.          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Generalized, Kanren-like tactics.                                         *)
(* ------------------------------------------------------------------------- *)

type kgoal = term list* goal;;

type ktactic = kgoal -> goalstate;;

type thm_ktactic = thm -> ktactic;;

let (inst_kgoal:instantiation->kgoal->kgoal) =
  fun p (mvs,g) ->
    let mvs' = intersect mvs (freesl (map (instantiate p) mvs)) in
    mvs',inst_goal p g;;

(* ------------------------------------------------------------------------- *)
(* Modify the original printer for goals and goalstacs to print              *)
(* metavariables.                                                            *)
(* ------------------------------------------------------------------------- *)

let print_vars =
  let print_var tm =
    let s,ty = dest_var tm in
    Format.print_string s;
    Format.print_string ":";
    print_type ty in
  let rec print_rest = function
    [] -> ()
  | tm::tml -> Format.print_string ", "; print_var tm; print_rest tml in
  function
    [] -> ()
  | tm::tml -> print_var tm; print_rest tml;;

let (print_kgoal : kgoal->unit) =
  let string_of_int3 n =
    if n < 10 then "  "^string_of_int n
    else if n < 100 then " "^string_of_int n
    else string_of_int n in
  let print_hyp n (s,th) =
    open_hbox();
    Format.print_string(string_of_int3 n);
    Format.print_string " [";
    open_hvbox 0;
    print_qterm (concl th);
    close_box();
    Format.print_string "]";
    (if not (s = "") then (Format.print_string (" ("^s^")")) else ());
    close_box();
    Format.print_newline() in
  let rec print_hyps n asl =
    if asl = [] then () else
    (print_hyp n (hd asl);
     print_hyps (n + 1) (tl asl)) in
  fun mvs,(asl,w) ->
    Format.print_newline();
    if asl <> [] then (print_hyps 0 (rev asl); Format.print_newline()) else ();
    if mvs <> [] then
      (Format.print_string "Metas: ";
       print_vars mvs;
       Format.print_newline())
    else ();
    print_qterm w; Format.print_newline();;

let (print_goalstack:goalstack->unit) =
  let print_goalstate k gs =
    let ((mvs,_),gl,_) = gs in
    let n = length gl in
    let s = if n = 0 then "No subgoals" else
              (string_of_int k)^" subgoal"^(if k > 1 then "s" else "")
           ^" ("^(string_of_int n)^" total)" in
    Format.print_string s; Format.print_newline();
    if gl = [] then () else
    do_list (curry print_kgoal mvs o C el gl) (rev(0--(k-1))) in
  fun l ->
    if l = [] then Format.print_string "Empty goalstack"
    else if tl l = [] then
      let (_,gl,_ as gs) = hd l in
      print_goalstate 1 gs
    else
      let (_,gl,_ as gs) = hd l
      and (_,gl0,_) = hd(tl l) in
      let p = length gl - length gl0 in
      let p' = if p < 1 then 1 else p + 1 in
      print_goalstate p' gs;;

#install_printer print_goal;;
#install_printer print_goalstack;;

(* ------------------------------------------------------------------------- *)
(* top_thm done right!                                                       *)
(* ------------------------------------------------------------------------- *)

let fix_top_thm() =
  let ((_,inst),[],f)::_ = !current_goalstack in
  f inst [];;

let ktop_thm() =
  match !current_goalstack with
    [] -> failwith "ktop_thm: empty goalstack"
  | ((_,inst),[],f)::_ -> f inst []
  | _ -> failwith "ktop_thm: proof not finished";;

(* ------------------------------------------------------------------------- *)
(* Meta goals.                                                               *)
(* ------------------------------------------------------------------------- *)

parse_as_binder "META";;
parse_as_infix ("ENTAILS",(0,"right"));;
parse_as_infix ("AND",(1,"right"));;

let META = new_definition `(META) = (?)`;;
let ENTAILS = new_definition `(ENTAILS) = (==>)`;;
let MAND = new_definition `(AND) = (/\)`;;

let is_meta = is_binder "META";;
let dest_meta = dest_binder "META";;
let strip_meta = splitlist dest_meta;;

let is_mand = is_binary "AND";;
let dest_mand = dest_binary "AND";;
let split_mand = striplist dest_mand;;

let is_entails = is_binary "ENTAILS";;
let dest_entails = dest_binary "ENTAILS";;

let dest_kanren_goal tm =
  let mvars,rtm = strip_meta tm in
  try let btm,htm = dest_entails rtm in
      mvars,(rev(split_mand btm),htm)
  with Failure _ -> mvars,([],rtm);;

(* Example *)
(*
dest_kanren_goal
  `META X.
     X = 5 ==> fives X AND
     fives X ==> fives X
     ENTAILS
     fives X`;;
*)

let set_kanren_goal =
  let propagate_thm i [th] = INSTANTIATE_ALL i th in
  fun tm ->
    let mvars,(tml,w) = dest_kanren_goal tm in
    let asl = map (fun th -> "",ASSUME th) tml in
    current_goalstack := [(mvars,null_inst),[asl,w],propagate_thm];;

(* ------------------------------------------------------------------------- *)
(* Debug tools.                                                              *)
(* ------------------------------------------------------------------------- *)

let trace_justification : string -> justification -> justification =
  fun s just ((_,alist,_) as inst) ths ->
    Format.print_string ("trace_justification "^s);
    Format.print_string ": ";
    do_list (fun (tm,v) -> print_qterm tm;
                           Format.print_string " <- ";
                           print_qterm v;
                           Format.print_string ", ")
            alist;
    Format.print_newline();
    do_list (fun th -> print_thm th; Format.print_newline()) ths;
    try just inst ths with
      Failure _ -> failwith "trace_justification: justification failed";;

let trace_ktactic msg ktac (mvs,g) =
  Format.print_string "trace_ktactic ";
  Format.print_string msg;
  Format.print_string ":\nMetas: ";
  do_list (fun tm -> print_qterm tm; Format.print_string ", ") mvs;
  Format.print_string "\nGoal:\n";
  print_goal g;
  Format.print_newline();
  ktac (mvs,g);;

(* ------------------------------------------------------------------------- *)
(* Basic tactics.                                                            *)
(* ------------------------------------------------------------------------- *)

let fresh_thm th =
  let vars,bth = splitlist SPEC_VAR th in
  let vars' = map (genvar o snd o dest_var) vars in
  let bth' = INST (zip vars' vars) bth in
  GENL vars' bth';;

(* Test *)
(*
UNDISCH (ARITH_RULE `x = 1 ==> !x y. x + y = y + x`);;
fresh_thm it;;
*)

let ACCEPT_KTAC : thm_ktactic =
  let propagate_thm th i [] = INSTANTIATE_ALL i th in
  fun th ->
    let th = fresh_thm th in
    let avs = fst (strip_forall (concl th))
    and th = SPEC_ALL th in
    fun (mvs,(asl,w)) ->
      let insts = term_unify (union avs mvs) (concl th) w in
      let th' = INSTANTIATE insts th in
      let insts' = term_unify mvs (concl th') w in
      ([],insts'),[],propagate_thm th';;

let propagate_mp rth i [th] =
  MP (INSTANTIATE_ALL i rth) th;;

(* Instrumented version for debug. *)
(*
let propagate_mp rth i [th] =
  Format.print_string "propagate_mp:\n";
  print_thm rth; Format.print_newline();
  print_thm (INSTANTIATE_ALL i rth); Format.print_newline();
  MP (INSTANTIATE_ALL i rth) th;;
*)

(* The following version works, but pollutes the goal with unneeded
   meta variables and redoundant instantiation. *)
(*
let (MP_KTAC : thm -> ktactic) =
  fun th ->
    let th = fresh_thm th in
    let avs,tm = strip_forall(concl th) in
    let btm,htm = dest_imp tm in
    fun mvs,(asl,w) ->
      let mvs' = union avs mvs in
      let inst1 = term_unify mvs' w htm in
      let asl' = map (fun s,th -> s,INSTANTIATE inst1 th) asl in
      let gl = asl',instantiate inst1 btm in
      let th' = SPEC_ALL (INSTANTIATE_ALL inst1 th) in
      (mvs',inst1),[gl],propagate_mp th';;
*)

let (MP_KTAC : thm -> ktactic) =
  fun th ->
    let th = fresh_thm th in
    let avs,tm = strip_forall(concl th) in
    let btm,htm = dest_imp tm in
    fun mvs,(asl,w) ->
      let mvs' = union avs mvs in
      let inst1 = term_unify mvs' htm w in
      let mvs'',gl = inst_kgoal inst1 (mvs',(asl,btm)) in
      let th' = INSTANTIATE_ALL inst1 (SPEC_ALL th) in
      let htm' = rand(concl th') in
      let inst = term_unify mvs w htm' in
      (mvs'',inst),[gl],propagate_mp th';;

(* ------------------------------------------------------------------------- *)
(* Tactic composition.                                                       *)
(* ------------------------------------------------------------------------- *)

let propagate_empty (i:instantiation) ([]:thm list) : thm list = [];;

let compose_justs
    (n:int)
    (just1:justification)
    (just2:instantiation -> thm list -> thm list)
    (i:instantiation)
    (ths:thm list)
    : thm list =
  let ths1,ths2 = chop_list n ths in
  (just1 i ths1)::(just2 i ths2);;

(* Il valore di ritorno di seqapply e "quasi" un goalstate ma la terza
   componente e' una justification "multipla".
   La terza componente e' una funzione
     j inst (sths@oths)
   dove sths sono le soluzione ai sottogoal del goal corrente generati
   dalla tattica corrente, mentre le altre sono le soluzioni agli
   altri sottogoal (ricorsivamente).
   L'output e' dato da una lista con il primo teorema soluzione del
   sottogoal corrente e gli altri teoremi soluzioni dei restanti
   sottogoal.

   La propagazione delle meta variabili non e' ottimale, ma la nostra
   nuova versione di ktacsequence filtra il risultato finale.
*)

let rec seqapply (l1:ktactic list) (l2:kgoal list)
          : (term list * instantiation) * goal list *
            (instantiation -> thm list -> thm list) =
 match (l1,l2) with
   ([],[]) -> null_meta,[],propagate_empty
 | ((ktac:ktactic)::ktacs),((kgoal:kgoal)::kgoals) ->
          let ((mvs1,insts1),gls1,just1) = ktac kgoal in
          let kgoals' = map (inst_kgoal insts1) kgoals in
          let ((mvs2,insts2),gls2,just2) = seqapply ktacs kgoals' in
          ((union mvs1 mvs2,compose_insts insts1 insts2),
           gls1@gls2,compose_justs (length gls1) just1 just2)
 | _,_ -> failwith "seqapply: Length mismatch";;

let justsequence
    (just1:justification)
    (just2:instantiation -> thm list -> thm list)
    (insts2:instantiation)
    : justification =
  fun i ths -> just1 (compose_insts insts2 i) (just2 i ths);;

(* Version that filters the propagated meta variables. *)
let (ktacsequence : goalstate -> ktactic list -> goalstate) =
  fun ((mvs1,insts1),gls1,just1) ktacl ->
    let ((mvs2,insts2),gls2,just2) =
      seqapply ktacl (map (fun g -> mvs1,g) gls1) in
    let just = justsequence just1 just2 insts2 in
    let inst = compose_insts insts1 insts2 in
    let mvs = freesl (map (instantiate inst) (union mvs1 mvs2)) in
    ((mvs,inst),gls2,just);;

(* Version with redundant metas. *)
(*
let (ktacsequence : goalstate -> ktactic list -> goalstate) =
  fun ((mvs1,insts1),gls1,just1) ktacl ->
    let ((mvs2,insts2),gls2,just2) =
      seqapply ktacl (map (fun g -> mvs1,g) gls1) in
    let just = justsequence just1 just2 insts2 in
    ((union mvs1 mvs2,compose_insts insts1 insts2),gls2,just);;
*)

let (kthenl_: ktactic -> ktactic list -> ktactic) =
  fun ktac1 ktac2l g -> ktacsequence (ktac1 g) ktac2l;;

let (kthen_: ktactic -> ktactic -> ktactic) =
  fun ktac1 ktac2 g ->
    let _,gls,_ as gstate = ktac1 g in
    ktacsequence gstate (replicate ktac2 (length gls));;

(*
let (THEN),(THENL) =
  then_,thenl_;;
*)

(* ------------------------------------------------------------------------- *)
(* Fail/resume reasoning patterns.                                           *)
(* ------------------------------------------------------------------------- *)

let (korelse_: ktactic -> ktactic -> ktactic) =
  fun ktac1 ktac2 g ->
    try ktac1 g with Failure _ -> ktac2 g;;

let (FAIL_KTAC: string -> ktactic) =
  fun tok g -> failwith tok;;

let (NO_KTAC: ktactic) =
  FAIL_KTAC "NO_KTAC";;

let (ALL_KTAC:ktactic) =
  fun (mvs,g) -> (mvs,null_inst),[g],fun _ [th] -> th;;

let KTRY ktac =
  korelse_ ktac ALL_KTAC;;

let rec KREPEAT ktac g =
  (korelse_ (kthen_ ktac (KREPEAT ktac)) ALL_KTAC) g;;

let KEVERY ktacl =
  itlist kthen_ ktacl ALL_KTAC;;

let (KFIRST: ktactic list -> ktactic) =
  end_itlist korelse_;;

let MAP_KEVERY ktacf lst =
  KEVERY (mapfilter ktacf lst);;

let MAP_KFIRST ktacf lst =
  KFIRST (mapfilter ktacf lst);;

let (CHANGED_KTAC: ktactic -> ktactic) =
  fun ktac (mvs,g) as gs ->
    let (meta,gl,_ as gstate) = ktac gs in
    if meta = null_meta && length gl = 1 && hd gl = g
    then failwith "CHANGED_KTAC" else gstate;;

let rec REPLICATE_KTAC n ktac =
  if n <= 0 then ALL_KTAC else kthen_ ktac (REPLICATE_KTAC (n - 1) ktac);;

(* ------------------------------------------------------------------------- *)
(* Higher-order tactics and tacticals.                                       *)
(* ------------------------------------------------------------------------- *)

let (FIRST_ASSUM_KTAC: thm_ktactic -> ktactic) =
  fun ktac (mvs,(asl,w)) as kg ->
    try MAP_KFIRST (fun (_,th) -> ktac th) asl kg with
      Failure _ -> failwith "pippo";;

(* ------------------------------------------------------------------------- *)
(* Interactive use of tactics.                                               *)
(* ------------------------------------------------------------------------- *)

(* Con propagazione "ridotta" dell'instanziazione. *)
(* Attenzione! Usa inst_goal invece di inst_kgoal! Come mai???? *)
(*
let (kby:ktactic->refinement) =
  fun ktac ((mvs,inst),gls,just) ->
    if gls = [] then failwith "No goal set" else
    let g = hd gls
    and ogls = tl gls in
    let ((newmvs,newinst),subgls,subjust) = ktac (mvs,g) in
    let n = length subgls in
    let mvs' = union newmvs mvs
    and inst' = compose_insts inst newinst
    and gls' = subgls @ map (inst_goal newinst) ogls in
    let just' i ths =
      let cths,oths = chop_list n ths in
      let sths = subjust i cths :: oths in
      just i sths in
    (mvs',inst'),gls',just';;
*)

(* New version with correct(?) propagation of meta variables (inst_kgoal). *)
let (kby:ktactic->refinement) =
  fun ktac ((mvs,inst),gls,just) ->
    if gls = [] then failwith "No goal set" else
    let g = hd gls
    and ogls = tl gls in
    let ((newmvs,newinst),subgls,subjust) = ktac (mvs,g) in
    let n = length subgls in
    let okgls = map (curry (inst_kgoal newinst) mvs) ogls in
    let omvs = unions (map fst okgls) in
    let inst' = compose_insts inst newinst
    and gls' = subgls @ map snd okgls in
    let just' i ths =
      let cths,oths = chop_list n ths in
      let sths = subjust i cths :: oths in
      just i sths in
    (union newmvs omvs,inst'),gls',just';;

let ke ktac = refine(kby ktac);;

let ktactic_of_tactic (tac:tactic) : ktactic =
  fun (mvs,g) ->
    let ((mvs',inst),gls,just) = tac g in
    ((union mvs mvs',inst),gls,just);;

(* ------------------------------------------------------------------------- *)
(* Our favorite example.                                                     *)
(* ------------------------------------------------------------------------- *)

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
p();;
(*
ke (MP_KTAC (ASSUME `!X Y:A Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z`));;
*)
ke (FIRST_ASSUM_KTAC MP_KTAC);;
ke (ktactic_of_tactic CONJ_TAC);;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

set_kanren_goal
  `META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`;;
p ();;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

let KTAC_PROOF (gstate : goalstate) (ktac:ktactic) : instantiation * thm =
  let (_,inst),sgs,just = kby ktac gstate in
  if sgs <> [] then failwith "KTAC_PROOF: Unsolved goals" else
  inst,just inst [];;

let (kprove : term * ktactic -> term list * thm) = 
  let propagate_thm i [th] = INSTANTIATE_ALL i th in
  fun tm,ktac ->
    let mvs,(atms,w) = dest_kanren_goal tm in
    let asl = map (fun tm -> "",ASSUME tm) atms in
    let gstate = (mvs,null_inst),[asl,w],propagate_thm in
    let inst,th = KTAC_PROOF gstate ktac in
    let th =
      let t' = concl th in
      if t' = w then th else
      try EQ_MP (ALPHA t' (instantiate inst w)) th
      with Failure _ ->
        failwith "kprove: tactic generated wrong theorem" in
    let eqs = map (fun v -> mk_eq(v,instantiate inst v)) mvs in
    eqs,th;;

kprove
 (`META X:A.
     (!Y:A. ancestor Y pluto)
     ENTAILS
     ancestor pippo X`,
  FIRST_ASSUM_KTAC ACCEPT_KTAC);;

(* ------------------------------------------------------------------------- *)
(* Example without axioms.                                                   *)
(* ------------------------------------------------------------------------- *)

(*
needs "Library/rstc.ml";;

let PARENT_RULES,PARENT_INDUCT,PARENT_CASES = new_inductive_definition
  `PARENT 3 1 /\
   PARENT 42 3`;;

let PARENT_1,PARENT_2 = CONJ_PAIR PARENT_RULES;;

set_kanren_goal
  `META X:num. RTC PARENT 42 X`;;
ke(MP_KTAC (ISPEC `PARENT` RTC_TRANS));;
ke (ktactic_of_tactic CONJ_TAC);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_2);;
ke (MP_KTAC (ISPEC `PARENT` RTC_INC));;
ke (ACCEPT_KTAC PARENT_1);;
top_thm();;
*)


(* ------------------------------------------------------------------------- *)

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
let cg = !current_goalstack;;
p();;

(* 0 : funziona! *)
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC) (ktactic_of_tactic CONJ_TAC));;
ke (trace_ktactic "*" (FIRST_ASSUM_KTAC ACCEPT_KTAC));;
ke (FIRST_ASSUM_KTAC ACCEPT_KTAC);;
ktop_thm();;

(* 1 : funziona! *)
current_goalstack := cg; p();;
ke (kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                    (ktactic_of_tactic CONJ_TAC))
           (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

kprove
 (`META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`,
  kthen_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                 (ktactic_of_tactic CONJ_TAC))
         (trace_ktactic "#" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;

(* 2 : error tryfind *)
current_goalstack := cg; p();;
ke (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
           (kthen_ (ktactic_of_tactic CONJ_TAC)
                   (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 3 : error tryfind *)
current_goalstack := cg; p();;
ke (trace_ktactic "1" (FIRST_ASSUM_KTAC MP_KTAC));;
ke (kthen_ (trace_ktactic "2" (ktactic_of_tactic CONJ_TAC))
           (trace_ktactic "3" (FIRST_ASSUM_KTAC ACCEPT_KTAC)));;
ktop_thm();;

(* 4 : funziona! *)
current_goalstack := cg; p();;
ke (kthenl_ (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                    (ktactic_of_tactic CONJ_TAC))
            [FIRST_ASSUM_KTAC ACCEPT_KTAC;
             FIRST_ASSUM_KTAC ACCEPT_KTAC]);;
ktop_thm();;

(* ------------------------------------------------------------------------- *)

let FIND_KTAC:ktactic =
  KREPEAT
    (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
              (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                      (ktactic_of_tactic (REPEAT CONJ_TAC))));;

(* Pb: Introdurre una meta implicazione?! *)
(* Questo codice assume che l'implicazione non occorra nei goal. *)
let APPLY_KTAC:thm_ktactic =
  fun th -> try MP_KTAC th with Failure _ -> ACCEPT_KTAC th;;

let PROLOG_KTAC:ktactic =
  KREPEAT
    (kthen_ (FIRST_ASSUM_KTAC APPLY_KTAC)
            (ktactic_of_tactic (REPEAT CONJ_TAC)));;

set_kanren_goal
  `(!X Y Z:A. l X Y /\ q Y Z ==> q X Z) AND
   (!X:A. q X X) AND
   (!X Y. l X Y ==> l Y X) AND
   l d e AND l a c AND l a d AND l d c AND l b c
   ENTAILS
   q a b`;;
let cg = !current_goalstack;;
p();;
ke PROLOG_KTAC;;
ktop_thm();;

current_goalstack := cg; p();;
ke FIND_KTAC;;
ktop_thm();;

current_goalstack := cg; p();;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ke (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
             (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                     (ktactic_of_tactic (REPEAT CONJ_TAC))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (REPLICATE_KTAC 8
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (ktactic_of_tactic (REPEAT CONJ_TAC)))));;
ktop_thm();;

current_goalstack := cg; p();;
ke (KREPEAT
     (korelse_ (FIRST_ASSUM_KTAC ACCEPT_KTAC)
               (kthen_ (FIRST_ASSUM_KTAC MP_KTAC)
                       (ktactic_of_tactic (REPEAT CONJ_TAC)))));;
ktop_thm();;

(* ------------------------------------------------------------------------- *)

(*;;
META_SPEC_TAC
X_META_EXISTS_TAC
*)

(* ------------------------------------------------------------------------- *)
(* Tactic for reflexivity.                                                   *)
(* ------------------------------------------------------------------------- *)

let REFL_KTAC : ktactic =
  let propagate_thm th i [] = INSTANTIATE_ALL i th in
  fun mvs,(asl,w) ->
    let ltm,rtm = dest_eq w in
    let inst = term_unify mvs ltm rtm in
    let th = REFL (instantiate inst ltm) in
    ([],inst),[],propagate_thm th;;

(* Example 1 *)
set_kanren_goal `META A B. [A;1;2] = [0;1;B]`;;
p();;
ke REFL_KTAC;;
ktop_thm();;

(* Example 2 *)
set_kanren_goal `META A B C. [A;C;2] = [0;A;B]`;;
p();;
ke REFL_KTAC;;
ktop_thm();;

(* ------------------------------------------------------------------------- *)
(* Experiment with lists.                                                    *)
(* ------------------------------------------------------------------------- *)

let APPEND_CONS = prove
 (`!x:A xs ys zs. APPEND xs ys = zs ==> APPEND (CONS x xs) ys = CONS x zs`,
  REWRITE_TAC[APPEND; CONS_11]);;

let NUM_APPEND_CONS = INST_TYPE [`:num`,aty] APPEND_CONS;;
let NUM_APPEND_NIL = INST_TYPE [`:num`,aty] (CONJUNCT1 APPEND);;

(* Example 1 *)
set_kanren_goal `META a b x y z. APPEND [1;a;3] [b;5] = [x;2;3;y;z]`;;
p();;
ke (KREPEAT (MP_KTAC NUM_APPEND_CONS));;
ke (ACCEPT_KTAC NUM_APPEND_NIL);;
ktop_thm();;

kprove
 (`META a b x y z. APPEND [1;a;3] [b;5] = [x;2;3;y;z]`,
  kthen_ (KREPEAT (MP_KTAC NUM_APPEND_CONS))
         (ACCEPT_KTAC NUM_APPEND_NIL));;

(* Example 2 *)
set_kanren_goal `META a b x y z. APPEND [1;a;3] [b;5] = [x;2;3;y;z]`;;
p();;
e (REWRITE_TAC[APPEND]);;
ke REFL_KTAC;;
ktop_thm();;

kprove
 (`META a b x y z. APPEND [1;a;3] [b;5] = [x;2;3;y;z]`,
  kthen_ (ktactic_of_tactic (REWRITE_TAC[APPEND]))
         REFL_KTAC);;
