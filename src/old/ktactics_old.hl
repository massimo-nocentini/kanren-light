let (MATCH_MP_KTAC : thm -> ktactic) =
  fun th ->
    let th' = fresh_thm th in
    let vars,tm = strip_forall(concl th') in
    let btm,htm = dest_imp tm in
    fun mvl,(asl,w) ->
      let newvars = vars@mvl in
      let inst1 = term_unify newvars w htm in
      let gl = asl,instantiate inst1 btm in
      ((newvars,inst1),[gl],
       trace_justification "MATCH_MP_KTAC" (propagate_mp (SPEC_ALL th')));;

let (MATCH_ACCEPT_KTAC : thm_ktactic) =
  let propagate_thm th i [] =
    try INSTANTIATE_ALL i th with
      Failure _ -> failwith "MATCH_ACCEPT_KTAC justification" in
  fun th ->
    let th' = fresh_thm th in
    let vars,tm = strip_forall(concl th') in
    fun mvl,(asl,w) ->
      let newvars = vars@mvl in
      let inst1 = term_unify newvars w tm in
      (([],inst1),[],propagate_thm (SPEC_ALL th'));;

(* ------------------------------------------------------------------------- *)
(* Questa variante di MATCH_ACCEPT_KTAC e' sbagliata perche' non da' le      *)
(* informazioni necessarie sull'instanziazione che poi dovranno essere       *)
(* applicate ai teoremi.                                                     *)
(* ------------------------------------------------------------------------- *)

(*
let (MATCH_ACCEPT_KTAC : thm -> ktactic) =
  let propagate_thm th _ [] = th in
  fun th ->
    let th' = fresh_thm th in
    let vars,tm = strip_forall(concl th') in
    fun mvl,(asl,w) ->
      let newvars = vars@mvl in
      let inst1 = term_unify newvars w tm in
      ((newvars,null_inst),[],propagate_thm (INSTANTIATE_ALL inst1 th'));;
*)

(* Non va bene perche' non usa orelse_, si focalizza su una ipotesi. *)
(*
let (FIRST_ASSUM_KTAC: thm_ktactic -> ktactic) =
  fun tktac ((mvs,(asl,w)) as g) -> tryfind (fun (_,th) -> tktac th g) asl;;
*)

(* Version with redundant instatiation. *)
(*
let (kby:ktactic->refinement) =
  fun ktac ((mvs,inst),gls,just) ->
    if gls = [] then failwith "No goal set" else
    let g = hd gls
    and ogls = tl gls in
    let ((newmvs,newinst),subgls,subjust) = ktac (mvs,g) in
    let n = length subgls in
    let mvs' = union newmvs mvs
    and inst' = compose_insts inst newinst
    and gls' = subgls @ map (inst_goal newinst) ogls in
    let just' i ths =
      let i' = compose_insts inst' i in
      let cths,oths = chop_list n ths in
      let sths = subjust i cths :: oths in
      just i' sths in
    (mvs',inst'),gls',just';;
*)

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;
(*;;
p();;
ke (MATCH_MP_KTAC
  (ASSUME `!X':A Y':A Z':A. ancestor X' Y' /\ ancestor Y' Z' ==> ancestor X' Z'`));;
e CONJ_TAC;;
ke (MATCH_ACCEPT_KTAC (ASSUME `ancestor (pippo:A) (pluto:A) : bool`));;
hd (!current_goalstack);;
ke (MATCH_ACCEPT_KTAC (ASSUME `ancestor (pluto:A) (paperino:A) : bool`));;
top_thm();;
*)

