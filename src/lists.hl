(* ========================================================================= *)
(* Examples with list of numbers.                                            *)
(* ========================================================================= *)

type_invention_warning := false;;
needs "Permutation/make.ml";;
type_invention_warning := true;;

(* ------------------------------------------------------------------------- *)
(* Append.                                                                   *)
(* ------------------------------------------------------------------------- *)

let APPEND_CONS = prove
 (`!x:A xs ys zs. APPEND xs ys = zs ==> APPEND (CONS x xs) ys = CONS x zs`,
  REWRITE_TAC[APPEND; CONS_11]);;

let NUM_APPEND_CONS = INST_TYPE [`:num`,aty] APPEND_CONS;;
let NUM_APPEND_NIL = INST_TYPE [`:num`,aty] (CONJUNCT1 APPEND);;

kprove
 (`META a b x y z. APPEND [1;a;3] [b;5] = [x;2;3;y;z]`,
  kthen_ (KREPEAT (MP_KTAC NUM_APPEND_CONS))
         (ACCEPT_KTAC NUM_APPEND_NIL));;

kprove
 (`META a b x y z. APPEND [1;a;3] [b;5] = [x;2;3;y;z]`,
  kthen_ (TAC_KTAC (REWRITE_TAC[APPEND])) REFL_KTAC);;

(* ------------------------------------------------------------------------- *)
(* Filter.                                                                   *)
(* ------------------------------------------------------------------------- *)

let FILTER_HORN = prove
 (`(!P:A->bool. FILTER P [] = []) /\
   (!P x:A xs ys. P x /\ FILTER P xs = ys ==> FILTER P (CONS x xs) = CONS x ys) /\
   (!P x:A xs ys. ~P x /\ FILTER P xs = ys ==> FILTER P (CONS x xs) = ys)`,
  REWRITE_TAC[FILTER] THEN REPEAT STRIP_TAC THEN COND_CASES_TAC THEN
  ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);;

let NUM_FILTER_HORN = INST_TYPE [`:num`,aty] FILTER_HORN;;

let [NUM_FILTER_NIL; NUM_FILTER_LE_HORN; NUM_FILTER_GT_HORN] =
  CONJUNCTS NUM_FILTER_HORN;;

let NUM_FILTER_KTAC : ktactic =
  (KREPEAT o KFIRST)
  [ACCEPT_KTAC NUM_FILTER_NIL;
   kthen_ (kthen_ (MP_KTAC NUM_FILTER_LE_HORN) (TAC_KTAC BETA_TAC))
                  (CONV_KTAC NUM_REDUCE_CONV);
   kthen_ (kthen_ (MP_KTAC NUM_FILTER_GT_HORN) (TAC_KTAC BETA_TAC))
                  (CONV_KTAC NUM_REDUCE_CONV)];;

kprove(`META ys. FILTER (\y. y <= 3) [2; 1] = ys`,
  NUM_FILTER_KTAC);;
kprove(`META ys. FILTER (\y. y <= 1) [2; 3] = ys`,
  NUM_FILTER_KTAC);;
kprove(`META ys. FILTER (\y. y <= 3) [2; 1; 3] = ys`,
  NUM_FILTER_KTAC);;
kprove(`META ys. FILTER (\y. y <= 1) [2; 3; 1] = ys`,
  NUM_FILTER_KTAC);;

(* ------------------------------------------------------------------------- *)
(* Sort.                                                                     *)
(* ------------------------------------------------------------------------- *)

let SORT = new_definition
  `SORT le xs ys <=> xs:A list PERMUTED ys /\ ORDERED le ys`;;

let SORT_NIL = prove
 (`SORT (le:A->A->bool) [] []`,
  REWRITE_TAC[SORT; PERMUTED_RULES; ORDERED_RULES]);;

let QUICKSORT_CONS = prove
 (`!x:A xs ys xs1 xs2 ys1 ys2.
     FILTER (\y. le y x) xs = xs1 /\
     SORT le xs1 ys1 /\
     FILTER (\y. ~le y x) xs = xs2 /\
     SORT le xs2 ys2 /\
     APPEND ys1 (CONS x ys2) = ys
     ==> SORT le (CONS x xs) ys`,
  CHEAT_TAC);;

let NUM_SORT_NIL =
  INST [`(<=)`,`le:num->num->bool`] (INST_TYPE [`:num`,aty] SORT_NIL);;
let NUM_QUICKSORT_CONS =
  INST [`(<=)`,`le:num->num->bool`] (INST_TYPE [`:num`,aty] QUICKSORT_CONS);;

(* ------------------------------------------------------------------------- *)
(* Quick sort stategy as a ktactic.                                          *)
(* ------------------------------------------------------------------------- *)

let QUICKSORT_KTAC : ktactic =
  let rec quicksort_ktac g =
    KFIRST [ACCEPT_KTAC NUM_SORT_NIL;
            kthenl_ (kthen_ (MP_KTAC NUM_QUICKSORT_CONS)
                            (TAC_KTAC (REPEAT CONJ_TAC)))
                    [NUM_FILTER_KTAC;
                     quicksort_ktac;
                     NUM_FILTER_KTAC;
                     quicksort_ktac;
                     kthen_ (TAC_KTAC (REWRITE_TAC[APPEND])) REFL_KTAC]]
           g in
  quicksort_ktac;;

kprove(`META ys. SORT (<=) [3;2;7;1;5] ys`, QUICKSORT_KTAC);;
kprove(`META ys. SORT (<=) [2;7;3;3;1;1;5] ys`, QUICKSORT_KTAC);;
kprove(`META ys. SORT (<=) [1;2;3;4] ys`, QUICKSORT_KTAC);;
kprove(`META ys. SORT (<=) [3;2;7;1;5] (APPEND [1; 2] ys)`, QUICKSORT_KTAC);;
kprove(`META x w. SORT (<=) [4;3;2;1] [x;2;3;w]`, QUICKSORT_KTAC);;
(* Ok: Fallisce perché il secondo argomento non è ordinato;;
kprove(`META x w. SORT (<=) [4;3;2;1] [x;2;1;w]`, QUICKSORT_KTAC);;
*)
(* La ricerca prolog non risolve questo problema (???);;
kprove(`META ys. SORT (<=) (APPEND [1; 2] ys) [1;2;3;4;5]`, QUICKSORT_KTAC);;
*)

(* ------------------------------------------------------------------------- *)
(* Reverse.                                                                  *)
(* ------------------------------------------------------------------------- *)

let NUM_REVERSE_NIL = INST_TYPE [`:num`,aty] (CONJUNCT1 REVERSE);;

let REVERSE_HORN = prove
 (`!x:A xs ys zs. REVERSE xs = ys /\ APPEND ys [x] = zs
                  ==> REVERSE (CONS x xs) = zs`,
  REWRITE_TAC[REVERSE] THEN MESON_TAC[]);;

let REVERSE_MIXED_HORN = prove
 (`!x:A xs ys. REVERSE xs = ys ==> REVERSE (CONS x xs) = APPEND ys [x]`,
  REWRITE_TAC[REVERSE] THEN MESON_TAC[]);;

let NUM_REVERSE_HORN = INST_TYPE [`:num`,aty] REVERSE_HORN;;
let NUM_REVERSE_MIXED_HORN = INST_TYPE [`:num`,aty] REVERSE_MIXED_HORN;;

let PURE_REVERSE_KTAC : ktactic =
  let rec reverse_ktac g =
    korelse_ (ACCEPT_KTAC NUM_REVERSE_NIL)
             (kthen_ (MP_KTAC NUM_REVERSE_MIXED_HORN)
                     reverse_ktac)
             g in
  reverse_ktac;;

let REVERSE_KTAC : ktactic =
  let rec reverse_ktac g =
    korelse_ (ACCEPT_KTAC NUM_REVERSE_NIL)
             (kthen_ (MP_KTAC NUM_REVERSE_HORN)
                     (kthenl_ (TAC_KTAC CONJ_TAC)
                              [reverse_ktac;
                               kthen_ (TAC_KTAC (REWRITE_TAC[APPEND]))
                                      REFL_KTAC]))
             g in
  reverse_ktac;;

(* Attenzione: Il rewrite non ha effetto! *)
let REVERSE_MIXED_KTAC : ktactic =
  let rec reverse_ktac g =
    korelse_ (kthen_ (MP_KTAC NUM_REVERSE_MIXED_HORN)
                     reverse_ktac)
             (kthen_ (kthen_ (TAC_KTAC (REWRITE_TAC[APPEND])) REFL_KTAC)
                     (ACCEPT_KTAC NUM_REVERSE_NIL))
             g in
  reverse_ktac;;

kprove(`META ys. REVERSE [1;2;3] = ys`, REFL_KTAC);;
kprove(`META ys. REVERSE [1;2;3] = ys`, REVERSE_KTAC);;
kprove(`META ys. REVERSE [1;2;3] = ys`, PURE_REVERSE_KTAC);;
kprove(`META ys. REVERSE [1;2;3] = ys`, REVERSE_MIXED_KTAC);;

(* ------------------------------------------------------------------------- *)
(* Lenght.                                                                   *)
(* ------------------------------------------------------------------------- *)

let CONJ_KTAC : ktactic = TAC_KTAC CONJ_TAC;;
let NUM_REDUCE_KTAC : ktactic = TAC_KTAC NUM_REDUCE_TAC;;

let CONJ_MP_KTAC : thm_ktactic =
  fun th -> kthen_ (MP_KTAC th) (TAC_KTAC (REPEAT CONJ_TAC));;

let NUM_LENGHT_HORN = prove
 (`LENGTH ([]:num list) = 0 /\
  (!h:num t n m. LENGTH t = m /\ n = SUC m ==> LENGTH (CONS h t) = n)`,
  REWRITE_TAC[LENGTH] THEN MESON_TAC[]);;

let NUM_LENGHT_NIL, NUM_LENGHT_CONS_HORN = CONJ_PAIR NUM_LENGHT_HORN;;

let LENGTH_KTAC : ktactic =
  let rec length_ktac g =
    korelse_ (ACCEPT_KTAC NUM_LENGHT_NIL)
             (kthenl_ (CONJ_MP_KTAC NUM_LENGHT_CONS_HORN)
                      [length_ktac;
                       kthen_ NUM_REDUCE_KTAC
                              REFL_KTAC])
             g in
  length_ktac;;

set_kanren_goal `META n. LENGTH [1;2;3] = n`; p();;
ke LENGTH_KTAC;;
ktop_thm();;

kprove(`META n. LENGTH [1;2;3] = n`, LENGTH_KTAC);;
kprove(`META x:num xs. LENGTH (CONS x xs) = 1`, LENGTH_KTAC);;
kprove(`META xs:num list. LENGTH xs = 1`, LENGTH_KTAC);;

(* Do not work!  Our kthenl_ do not perform backtracking from one branch
   to the previous ones. *)
(*;;
kprove(`META xs:num list. LENGTH xs = SUC (SUC 0)`, LENGTH_KTAC);;

set_kanren_goal `META xs:num list. LENGTH xs = SUC (SUC 0)`; p();;
ke (CONJ_MP_KTAC NUM_LENGHT_CONS_HORN);;
ke (ACCEPT_KTAC NUM_LENGHT_NIL);;
ke (kthen_ NUM_REDUCE_KTAC REFL_KTAC);;
ke (kthen_ (KTRY (CONV_KTAC (RAND_CONV NUM_SUC_CONV))) REFL_KTAC);;
ktop_thm();;
*)