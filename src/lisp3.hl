(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Printer for mgoalstacs.                                                   *)
(* ------------------------------------------------------------------------- *)

let print_goalstate (gs:goalstate) =
  let (_,gl,_) = gs in
  if gl = [] then () else
  do_list print_goal (rev gl);;

let (print_mgoalstack:mgoalstack->unit) =
  fun mgls ->
    if mgls = [] then Format.print_string "Empty mgoalstack" else
    let mgl = hd mgls in
    if mgl = Empty then Format.print_string "No (more) solutions" else
    print_goalstate (get mgl);;

#install_printer print_mgoalstack;;

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

let ALL2_RULES = prove
 (`(!R:A->B->bool. ALL2 R [] []) /\
   (!R h:A h':B t t'. R h h' /\ ALL2 R t t'
                      ==> ALL2 R (CONS h t) (CONS h' t'))`,
  REWRITE_TAC[ALL2]);;

let ALL2_NIL,ALL2_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] ALL2_RULES);;

(* Rev-Assoc relation. *)
let RELASSOC_RULES,RELASSOC_INDUCT,RELASSOC_CASES = new_inductive_definition
  `(!k:A v:B l. RELASSOC k (CONS (v,k) l) v) /\
   (!k k' v v' l. ~(k = k') /\ RELASSOC k l v'
                  ==> RELASSOC k (CONS (v,k') l) v')`;;

let RELASSOC_HEAD,REALASSOC_TAIL = CONJ_PAIR RELASSOC_RULES;;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES,EVAL_INDUCT,EVAL_CASES = new_inductive_definition
  `(!e q. EVAL e (List [Symbol "quote"; q]) q) /\
   (!e a x. RELASSOC a e x ==> EVAL e (Symbol a) x) /\
   (!e l. EVAL e (List (CONS (Symbol "lambda") l))
                 (List (CONS (Symbol "lambda") l))) /\
   (!e l l'. ALL2 (EVAL e) l l'
             ==> EVAL e (List (CONS (Symbol "list") l)) (List l')) /\
   (!e f x x' v b y.
      EVAL e f (List [Symbol "lambda"; List[Symbol v]; b]) /\
      EVAL e x x' /\ EVAL (CONS (x',v) e) b y
      ==> EVAL e (List [f; x]) y)`;;

let [EVAL_QUOTED; EVAL_SYMB; EVAL_LAMBDA; EVAL_LIST; EVAL_APP] =
  CONJUNCTS EVAL_RULES;;

(* ------------------------------------------------------------------------- *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

gg `??q. EVAL [] q q`;;
ee (APPLY_SLV EVAL_APP);;

  (* 1/3 *)
  ee CONJ_SLV;;
  ee (APPLY_SLV EVAL_LAMBDA);;

  (* 2/3 *)
  ee CONJ_SLV;;
  ee (APPLY_SLV EVAL_QUOTED);;

  (* 3/3 *)
  ee (APPLY_SLV EVAL_LIST);;
  ee (APPLY_SLV ALL2_CONS);;

    (* 1/2 *)
    ee CONJ_SLV;;
    ee (APPLY_SLV EVAL_SYMB);;
    ee (APPLY_SLV RELASSOC_HEAD);;

    (* 2/2 *)
    ee (APPLY_SLV ALL2_CONS);;

      (* 1/2 *)
      ee CONJ_SLV;;
      ee (APPLY_SLV EVAL_LIST);;
      ee (APPLY_SLV ALL2_CONS);;

        (* 1/2 *)
        ee CONJ_SLV;;
        ee (APPLY_SLV EVAL_QUOTED);;

        (* 2/2 *)
        ee (APPLY_SLV ALL2_CONS);;

          (* 1/2 *)
          ee CONJ_SLV;;
          ee (APPLY_SLV EVAL_SYMB);;
          ee (APPLY_SLV RELASSOC_HEAD);;

          (* 2/2 *)
          ee (APPLY_SLV ALL2_NIL);;

      (* 2/2 *)
      ee (APPLY_SLV ALL2_NIL);;

top_thm1();;

(* ------------------------------------------------------------------------- *)
(* Toward automation.                                                        *)
(* ------------------------------------------------------------------------- *)

gg `??q. EVAL [] q q`;;
ee (APPLY_SLV EVAL_APP);;

  (* 1/3 *)
  ee CONJ_SLV;;
  ee (PROLOG_SLV NO_CONV [EVAL_LAMBDA]);;

  (* 2/3 *)
  ee CONJ_SLV;;
  ee (PROLOG_SLV NO_CONV
        [ALL2_RULES; EVAL_QUOTED; EVAL_SYMB; EVAL_LIST; RELASSOC_HEAD]);;

  (* 3/3 *)
  ee (PROLOG_SLV NO_CONV
        [ALL2_RULES; EVAL_QUOTED; EVAL_SYMB; EVAL_LIST; RELASSOC_HEAD]);;

top_thm1();;

gg `??q. EVAL [] q q`;;
ee (THEN_SLV (APPLY_SLV EVAL_APP)
     (THEN_SLV (TACTIC_SLV (REPEAT CONJ_TAC))
        (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD])));;
take 6 (top_thms());;

(* ------------------------------------------------------------------------- *)
(* Ulteriore esperimenti.                                                    *)
(* ------------------------------------------------------------------------- *)


(*
gg `??q. EVAL [] q q`;;
ee (MAP_INTERLEAVE_SLV APPLY_SLV (CONJUNCTS EVAL_RULES));;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;


ee (APPLY_SLV EVAL_RULES);;



gg `??q. EVAL [] q q`;;
ee (APPLY_SLV EVAL_LIST);;
(*
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;
ee (APPLY_SLV ALL2_NIL);;
*)

ee (APPLY_SLV ALL2_CONS);;
ee CONJ_SLV;;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;
ee (APPLY_SLV ALL2_CONS);;
ee CONJ_SLV;;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;

top_thm1();;

*)