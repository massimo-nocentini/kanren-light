(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES,EVAL_INDUCT,EVAL_CASES = new_inductive_definition
  `(!e q. EVAL e (List [Symbol "quote"; q]) q) /\
   (!e a x. RELASSOC a e x ==> EVAL e (Symbol a) x) /\
   (!e l. EVAL e (List (CONS (Symbol "lambda") l))
                 (List (CONS (Symbol "lambda") l))) /\
   (!e l l'. ALL2 (EVAL e) l l'
             ==> EVAL e (List (CONS (Symbol "list") l)) (List l')) /\
   (!e f x x' v b y.
      EVAL e f (List [Symbol "lambda"; List[Symbol v]; b]) /\
      EVAL e x x' /\ EVAL (CONS (x',v) e) b y
      ==> EVAL e (List [f; x]) y)`;;

let [EVAL_QUOTED; EVAL_SYMB; EVAL_LAMBDA; EVAL_LIST; EVAL_APP] =
  CONJUNCTS EVAL_RULES;;

(*
let RELASSOC_SLV : solver =
  PROLOG_SLV NO_CONV [RELASSOC_RULES];;

let EVAL_QUOTED_SLV = APPLY_SLV EVAL_QUOTED;;
let EVAL_SYMBOL_SLV = THEN_SLV (APPLY_SLV EVAL_SYMB) RELASSOC_SLV;;
let EVAL_LAMBDA_SLV = APPLY_SLV EVAL_LAMBDA;;

let rec EVAL_LIST_SLV g = THEN_SLV (APPLY_SLV EVAL_LIST) ALL2_SLV g
and ALL2_SLV g =
  MPLUS_SLV (ACCEPT_SLV ALL2_NIL)
    (THEN_SLV (APPLY_SLV ALL2_CONS)
              (THENL_SLV CONJ_SLV [EVAL_SLV; ALL2_SLV]))
    g
and EVAL_APP_SLV g =
  THEN_SLV (APPLY_SLV EVAL_APP)
    (THEN_SLV (TACTIC_SLV (REPEAT CONJ_TAC)) EVAL_SLV)
    g
and EVAL_SLV g  =
  INTERLEAVE_SLV
    [EVAL_QUOTED_SLV; EVAL_SYMBOL_SLV; EVAL_LAMBDA_SLV;
     EVAL_LIST_SLV; EVAL_APP_SLV]
    g;;
*)

let rec RELASSOC_SLV : solver =
  fun g ->
    CONCAT_SLV (ACCEPT_SLV RELASSOC_HEAD)
               (THEN_SLV (RULE_SLV RELASSOC_TAIL) RELASSOC_SLV)
               g;;

let rec ALL2_SLV (slv:solver) : solver =
  fun g ->
    CONCAT_SLV (ACCEPT_SLV ALL2_NIL)
               (THEN_SLV (RULE_SLV ALL2_CONS)
                         (THENL_SLV CONJ_SLV [slv; ALL2_SLV slv]))
               g;;

let STEP_SLV : solver =
  COLLECT_SLV
    [CONJ_SLV;
     ACCEPT_SLV EVAL_QUOTED;
     THEN_SLV (RULE_SLV EVAL_SYMB) RELASSOC_SLV;
     ACCEPT_SLV EVAL_LAMBDA;
     RULE_SLV EVAL_LIST;
     RULE_SLV EVAL_APP;
     ACCEPT_SLV ALL2_NIL;
     RULE_SLV ALL2_CONS];;

let rec EVAL_SLV : solver =
  fun g ->
    CONCAT_SLV ALL_SLV (THEN_SLV STEP_SLV EVAL_SLV) g;;

gg `??q. EVAL [] q q`;;
ee EVAL_SLV;;
ss();;
ss();;
ss();;
ss();;
top_thm1();;
let s = top_thms () in
time (take 4) s;;

let sols = top_thms();;
let sols1 = next sols;;
let sols2 = time next sols1;;
let sols3 = time next sols2;;

let q0 = get sols
and q1 = get sols1
and q2 = get sols2
and q3 = get sols3;;

let [q0;q1;q2;q3] = it;;
rand(concl q1);;
vsubst [`"x":string`,`_633735:string`] (rand(concl q1));;
rand(concl q2);;
vsubst [`"x":string`,`_854999:string`] (rand(concl q2));;

vsubst [`"x":string`,`:string`] (rand(concl q2));;
rand(concl q3);;
vsubst [`"x":string`,`_4140356:string`] (rand(concl q3));;

let [th] = it;;
let quine = vsubst [`"x":string`,`_477070:string`] (rand(concl th));;
let mygoal = (vsubst [quine,`q:sexp`] `EVAL [] q q`);;

gg mygoal;;
ee (APPLY_SLV EVAL_APP);;
ee CONJ_SLV;;
ee (PROLOG_SLV NO_CONV [EVAL_RULES; ALL2_RULES; RELASSOC_RULES]);;
top_thm1();;

let EVAL_SLV : solver =
  fun mgoal ->
    let s = STEP_SLV mgoal in
    s ++ map EVAL_SLV s;;

let EVAL_SLV : solver =
  REPEAT_SLV
    STEP_SLV


gg `??q. EVAL [] q q`;;
ee EVAL_SLV;;
top_thm1();;
take 2 (top_thms());;

gg `??q. EVAL [] q q`;;
ee EVAL_APP_SLV;;
top_thm1();;
take 7 (top_thms());;

(* ------------------------------------------------------------------------- *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

gg `??q. EVAL [] q q`;;
ee (APPLY_SLV EVAL_APP);;

  (* 1/3 *)
  ee CONJ_SLV;;
  ee (APPLY_SLV EVAL_LAMBDA);;

  (* 2/3 *)
  ee CONJ_SLV;;
  ee (APPLY_SLV EVAL_QUOTED);;

  (* 3/3 *)
  ee (APPLY_SLV EVAL_LIST);;
  ee (APPLY_SLV ALL2_CONS);;

    (* 1/2 *)
    ee CONJ_SLV;;
    ee (APPLY_SLV EVAL_SYMB);;
    ee (APPLY_SLV RELASSOC_HEAD);;

    (* 2/2 *)
    ee (APPLY_SLV ALL2_CONS);;

      (* 1/2 *)
      ee CONJ_SLV;;
      ee (APPLY_SLV EVAL_LIST);;
      ee (APPLY_SLV ALL2_CONS);;

        (* 1/2 *)
        ee CONJ_SLV;;
        ee (APPLY_SLV EVAL_QUOTED);;

        (* 2/2 *)
        ee (APPLY_SLV ALL2_CONS);;

          (* 1/2 *)
          ee CONJ_SLV;;
          ee (APPLY_SLV EVAL_SYMB);;
          ee (APPLY_SLV RELASSOC_HEAD);;

          (* 2/2 *)
          ee (APPLY_SLV ALL2_NIL);;

      (* 2/2 *)
      ee (APPLY_SLV ALL2_NIL);;

top_thm1();;

(* ------------------------------------------------------------------------- *)
(* Toward automation.                                                        *)
(* ------------------------------------------------------------------------- *)

gg `??q. EVAL [] q q`;;
ee (APPLY_SLV EVAL_APP);;

  (* 1/3 *)
  ee CONJ_SLV;;
  ee (PROLOG_SLV NO_CONV [EVAL_LAMBDA]);;

  (* 2/3 *)
  ee CONJ_SLV;;
  ee (PROLOG_SLV NO_CONV
        [ALL2_RULES; EVAL_QUOTED; EVAL_SYMB; EVAL_LIST; RELASSOC_HEAD]);;

  (* 3/3 *)
  ee (PROLOG_SLV NO_CONV
        [ALL2_RULES; EVAL_QUOTED; EVAL_SYMB; EVAL_LIST; RELASSOC_HEAD]);;

top_thm1();;

gg `??q. EVAL [] q q`;;
ee (THEN_SLV (APPLY_SLV EVAL_APP)
     (THEN_SLV (TACTIC_SLV (REPEAT CONJ_TAC))
        (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD])));;
take 6 (top_thms());;

gg `??q. EVAL [] q q`;;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;
top_thm1();;
(* Diverge! *)
(*;;
take 2 (top_thms());;  
*)

(* ------------------------------------------------------------------------- *)
(* Ulteriore esperimenti.                                                    *)
(* ------------------------------------------------------------------------- *)


(*
gg `??q. EVAL [] q q`;;
ee (MAP_INTERLEAVE_SLV APPLY_SLV (CONJUNCTS EVAL_RULES));;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;


ee (APPLY_SLV EVAL_RULES);;



gg `??q. EVAL [] q q`;;
ee (APPLY_SLV EVAL_LIST);;
(*
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;
ee (APPLY_SLV ALL2_NIL);;
*)

ee (APPLY_SLV ALL2_CONS);;
ee CONJ_SLV;;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;
ee (APPLY_SLV ALL2_CONS);;
ee CONJ_SLV;;
ee (PROLOG_SLV NO_CONV [ALL2_RULES; EVAL_RULES; RELASSOC_HEAD]);;

top_thm1();;

*)