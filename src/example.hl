g `p a b /\ p b c /\ (!x y z. p x y /\ n y z ==> n x z) ==> ?x. n a x`;;
e (INTRO_TAC "hp1 hp2 rule");;
e (USE_THEN "rule" KANREN_TAC);;

?- ?x y. p a y /\ n y x

?1- ?x y. p a x
?2- ?x ?w. n (b w) x

(* ------------------------------------------------------------------------- *)

(*
set_kanren_goal
  `META X:A.
     (!X:A. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ASSERTS
     ancestor pippo X`;;
*)

;;

parse_as_binder "META";;
parse_as_infix ("ENTAILS",(0,"right"));;
parse_as_infix ("AND",(1,"right"));;

let META = new_definition `(META) = (?)`;;
let ENTAILS = new_definition `(ENTAILS) = (==>)`;;
let MAND = new_definition `(AND) = (/\)`;;

let is_meta = is_binder "META";;
let dest_meta = dest_binder "META";;
let strip_meta = splitlist dest_meta;;

let is_mand = is_binary "AND";;
let dest_mand = dest_binary "AND";;
let split_mand = striplist dest_mand;;

let is_entails = is_binary "ENTAILS";;
let dest_entails = dest_binary "ENTAILS";;

let dest_kanren_goal tm =
  let mvars,rtm = strip_meta tm in
  try let btm,htm = dest_entails rtm in
      mvars,(split_mand btm,htm)
  with Failure _ -> mvars,([],rtm);;

dest_kanren_goal
  `META X.
     X = 5 ==> fives X AND
     fives X ==> fives X
     ENTAILS
     fives X`;;

let propagate_thm i [th] = INSTANTIATE_ALL i th;;

let set_kanren_goal tm =
  let mvars,(tml,w) = dest_kanren_goal tm in
  let asl = map (fun th -> "",ASSUME th) tml in
  current_goalstack := [(mvars,null_inst),[asl,w],propagate_thm];;

set_kanren_goal
  `META X:A.
     (!X. ancestor X X) AND
     (!X Y Z. ancestor X Y /\ ancestor Y Z ==> ancestor X Z) AND
     ancestor pippo pluto AND
     ancestor pluto paperino
     ENTAILS
     ancestor pippo X`;;

let fresh_thm th =
  let tm = concl th in
  let vars,_ = strip_forall tm in
  let vars' = map (genvar o snd o dest_var) vars in
  let bth = INST (zip vars' vars) (SPEC_ALL th) in
  GENL vars' bth;;

(* ------- *)

(* TODO 1: Implementare KANREN_MP_TAC. *)
(* TODO 2: Implementare KANREN_CONJ_TAC *)

let hp =
  ASSUME `!X':A Y':A Z':A. ancestor X' Y' /\ ancestor Y' Z' ==> ancestor X' Z'`;;
let hp' = fresh_thm hp;;
let vars,tm = strip_forall(concl hp');;
let btm,htm = dest_imp tm;;
let ((mvl,_),((asl,w)::_),_) = hd !current_goalstack;;
let newvars = vars@mvl;;
let inst1 = term_unify newvars w htm;;

let gls = map (fun tm -> asl,tm) (conjuncts (instantiate inst1 btm));;

let just i [th1;th2] =
  INSTANTIATE_ALL i (CONJ th1 th2);;

let glst = ((newvars,inst1),gls,just);;

current_goalstack := glst :: !current_goalstack;;

let hp = ASSUME `ancestor (pippo:A) (pluto:A):bool`;;
let hp' = fresh_thm hp;;
(* ... *)
let tm = concl hp';;
let ((mvl,_),((asl,w)::_),_) = hd !current_goalstack;;
let newvars = mvl;;
let inst2 = term_unify newvars w htm;;
let gls = map (fun tm -> asl,tm) [];;

CONJ (INSTANTIATE_ALL inst2 hp')
     (ASSUME `ancestor (pluto:A) (paperino:A):bool`);;

INSTANTIATE_ALL inst1 ();;
