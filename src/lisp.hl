(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

(* Non serve, basta ALL2 *)
let LISTREL_RULES,LISTREL_INDUCT,LISTREL_CASES = new_inductive_definition
  `LISTREL R [] [] /\
   (!h h':A t t'. R h h' /\ LISTREL R t t'
                  ==> LISTREL R (CONS h t) (CONS h' t'))`;;

let LISTREL_NIL,LISTREL_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] LISTREL_RULES);;

let LISTREL_MONO = prove
  (`!R R' l m. (!x:A y:B. R x y ==> R' x y) /\ LISTREL R l m
               ==> LISTREL R' l m`,
   REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN
   DISCH_TAC THEN MATCH_MP_TAC LISTREL_INDUCT THEN
   ASM_MESON_TAC[LISTREL_RULES]);;

(* Rev-Assoc relation. *)
let RELASSOC_RULES,RELASSOC_INDUCT,RELASSOC_CASES = new_inductive_definition
  `(!k:A v:B l. RELASSOC k (CONS (v,k) l) v) /\
   (!k k' v v' l. ~(k = k') /\ RELASSOC k l v'
                  ==> RELASSOC k (CONS (v,k') l) v')`;;

let RELASSOC_HEAD,REALASSOC_TAIL = CONJ_PAIR RELASSOC_RULES;;

(* Zip-relation. *)
let ZIPPED_RULES,ZIPPED_INDUCT,ZIPPED_CASES = new_inductive_definition
  `ZIPPED [] [] [] /\
   (!x xs y ys zs. ZIPPED xs ys zs
                   ==> ZIPPED (CONS x xs) (CONS y ys) (CONS (x,y) zs))`;;

let ZIPPED_NIL,ZIPPED_CONS = CONJ_PAIR ZIPPED_RULES;;

(* ------------------------------------------------------------------------- *)
(* Helpers for sexp analyis.                                                 *)
(* ------------------------------------------------------------------------- *)

(* Matcher for lisp-like lambda forms. *)
let MATCHPROC_RULES,MATCHPROC_INDUCT,MATCHPROC_CASES = new_inductive_definition
  `!sexp vlist vars body.
     MATCHTAGGED "lambda" sexp [List vlist; body] /\
     LISTREL MATCHSYMB vlist vars
     ==> MATCHPROC sexp vars body`;;

let _ = prove
 (`MATCHPROC '(lambda (x y) (p x y)) ["x"; "y"] '(p x y)`,
  GEN_REWRITE_TAC I [MATCHPROC_CASES] THEN
  EXISTS_TAC `[Symbol "x"; Symbol "y"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHSYMB_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN CONJ_TAC THENL
  [MATCH_ACCEPT_TAC MATCHSYMB_RULES; MATCH_ACCEPT_TAC LISTREL_NIL]);;

let MATCHBETA_RULES,MATCHBETA_INDUCT,MATCHBETA_CASES = new_inductive_definition
  `!fn vars args body.
      MATCHPROC fn vars body
      ==> MATCHBETA (List (CONS fn args)) vars body args`;;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES,EVAL_INDUCT,EVAL_CASES =
  let EVAL_RULES',EVAL_INDUCT',EVAL_CASES' = new_inductive_definition
    `(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
     (!env env' sexp vars body args args' ret.
         MATCHBETA sexp vars body args /\ LISTREL (EVAL env) args args' /\
         ZIPPED args' vars env' /\ EVAL (APPEND env' env) body ret
         ==> EVAL env sexp ret) /\
     (!env sexp l l'. MATCHTAGGED "list" sexp l /\ LISTREL (EVAL env) l l'
                      ==> EVAL env sexp (List l')) /\
     (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                        ==> EVAL env sexp quoted)` in
  let pth = prove
   (hd (hyp EVAL_RULES'),
    MESON_TAC[injectivity "sexp"; LISTREL_MONO]) in
  PROVE_HYP pth EVAL_RULES',
  PROVE_HYP pth EVAL_INDUCT',
  PROVE_HYP pth EVAL_CASES';;

let [EVAL_SYMB; EVAL_BETA; EVAL_LIST; EVAL_QUOTED] = CONJUNCTS EVAL_RULES;;

(* ------------------------------------------------------------------------- *)
(* The classical quine in scheme.  Note that our evaluation do not use       *)
(* dynamic (non-static) scope. But this code do not depend on this.          *)
(*                                                                           *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

let QUINE = prove
 (`let quine = '((lambda (x) (list x (list (quote quote) x)))
                 (quote (lambda (x) (list x (list (quote quote) x))))) in
   EVAL [] quine quine`,
  LET_TAC THEN POP_ASSUM SUBST_VAR_TAC THEN
  MATCH_MP_TAC EVAL_BETA THEN
  REWRITE_TAC[APPEND_NIL; IMP_CONJ; RIGHT_EXISTS_AND_THM] THEN
  MAP_EVERY EXISTS_TAC
   [`['(lambda (x) (list x (list (quote quote) x))), "x"]`;
    `["x"]`;
    `'(list x (list (quote quote) x))`;
    `['(quote (lambda (x) (list x (list (quote quote) x))))]`] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC MATCHBETA_RULES THEN MATCH_MP_TAC MATCHPROC_RULES THEN
   EXISTS_TAC `[Symbol "x"]` THEN
   CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
   MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL; MATCHSYMB_RULES];
   ALL_TAC] THEN
  EXISTS_TAC `['(lambda (x) (list x (list (quote quote) x)))]` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL] THEN
   MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ZIPPED_CONS THEN MATCH_ACCEPT_TAC ZIPPED_NIL; ALL_TAC] THEN
  MATCH_MP_TAC EVAL_LIST THEN
  EXISTS_TAC `[Symbol "x"; '(list (quote quote) x)]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL] THEN
  MATCH_MP_TAC EVAL_LIST THEN EXISTS_TAC `['(quote quote); Symbol "x"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL] THEN
  MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD);;

(*
solve
 (`??q. SEXP q ==> EVAL [] q q`,
*)

(* ------------------------------------------------------------------------- *)
(* Prolog-style program for the evaluation of lisp programs.                 *)
(* ------------------------------------------------------------------------- *)

let BOOL_EQ_CLAUSES = ITAUT `~(T = F) /\ ~(F = T)`;;

let EVAL_SLV = PROLOG_SLV
  [MATCHSYMB_RULES; MATCHTAGGED_RULES;
   REWRITE_RULE[FORALL_AND_THM] LISTREL_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES;
   EQ_REFL; BOOL_EQ_CLAUSES];;
let lispeval = solve EVAL_SLV;;

(* Test MATCHSYMB *)
take 10 (lispeval `??ret. MATCHSYMB (Symbol "a") ret`);;
take 10 (lispeval `??ret. MATCHSYMB ret "a"`);;
take 10 (lispeval `??ret. MATCHSYMB '(a b) ret`);;

(* Test MATCHTAGGED *)
take 10 (lispeval `??s ret. MATCHTAGGED s '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "tag" '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "list" '(tag x y) ret`);;

(* Test LISTREL *)
take 10 (lispeval `??a. a = 1`);;
take 10 (lispeval `??a. LISTREL (=) [] a`);;
take 10 (lispeval `??a. LISTREL (=) a []`);;
take 10 (lispeval `??a. LISTREL (=) [1] [a]`);;
take 10 (lispeval `??a. LISTREL (=) [1] a`);;
take 3 (lispeval `??a b. LISTREL (=) a b`);;

(* Test RELASSOC *)
take 10 (lispeval `??k ret. RELASSOC k [0,T; 1,F] ret`);;
take 10 (lispeval `??k. RELASSOC k [0,T; 1,F] 1`);;

(* Test ZIPPED *)
take 10 (lispeval `??ret. ZIPPED [] [] ret`);;
take 10 (lispeval `??ret. ZIPPED [] ret []`);;
take 10 (lispeval `??ret. ZIPPED [1] [T] ret`);;
take 10 (lispeval `??ret. ZIPPED [1] ret [1,T]`);;

(* Test MATCHPROC *)
take 10 (lispeval `??vars body. MATCHPROC '(lambda (x) (x x)) vars body`);;


term_ty_unify [`x:A list`] `x:num list` `[]:A list`;;

(* ------------------------------------------------------------------------- *)
(* Hic sunt leones!!!                                                        *)
(* ------------------------------------------------------------------------- *)

(* Debug term_ty_unify *)

let tm1 = `MATCHSYMB (Symbol "x") AA`;;
let tm2 = `MATCHSYMB (Symbol str) str`;;
let mvar = [`AA:string`; `str:string`];;
term_ty_unify mvar tm1 tm2;;

let tm1 = `MATCHSYMB (Symbol "x") AA`;;
let tm2 = `MATCHSYMB (Symbol str) str`;;
let mvar = variables(mk_pair(tm1,tm2));;
map dest_var mvar;;
term_unify mvar tm1 tm2;;








g `MATCHPROC '(lambda (x) (x x)) ["x"] '(x x)`;;
e (MATCH_MP_TAC MATCHPROC_RULES);;
e (EXISTS_TAC `[Symbol "x"]`);;
e CONJ_TAC;;
e (MATCH_ACCEPT_TAC MATCHTAGGED_RULES);;

take 10 (lispeval `??a. LISTREL MATCHSYMB [Symbol "x"] [a]`);;
take 10 (lispeval `??a. LISTREL (=) [Symbol "x"] [a]`);;

e (MATCH_MP_TAC LISTREL_CONS);;
take 10 (lispeval `??a b. MATCHSYMB (Symbol "x") a /\ LISTREL MATCHSYMB [] b`);;


e CONJ_TAC;;
e (MATCH_ACCEPT_TAC MATCHSYMB_RULES);;
take 10 (lispeval `??a. LISTREL MATCHSYMB [] a`);;

e (MATCH_ACCEPT_TAC LISTREL_NIL);;
take 10 (lispeval `??a. LISTREL MATCHSYMB [] a`);;

top_thm();;

APPLY_SLV LISTREL_CONS
  (dest_mgoal `??a. LISTREL MATCHSYMB [Symbol "x"] a`);;
let (mvar,i),[gl],just = get it;;
let tm1 = snd gl;;
let tm2 = concl (SPEC `str:string` MATCHSYMB_RULES);;
let mvar1 = `str:string` :: mvar;;
term_ty_unify mvar1 tm1 tm2;;
term_unify mvar1 tm1 tm2;;
variables(mk_pair(tm1,tm2));;
subset it mvar1;;
map dest_var mvar1;;
map dest_var (variables(mk_pair(tm1,tm2)));;

THENL_SLV (THEN_SLV (APPLY_SLV LISTREL_CONS) CONJ_SLV)
  [ALL_SLV; ACCEPT_SLV LISTREL_NIL]
  (dest_mgoal `??a. LISTREL MATCHSYMB [Symbol "x"] a`);;

THENL_SLV (THEN_SLV (APPLY_SLV LISTREL_CONS) CONJ_SLV)
  [ACCEPT_SLV MATCHSYMB_RULES; ACCEPT_SLV LISTREL_NIL]
  (dest_mgoal `??a. LISTREL MATCHSYMB [Symbol "x"] a`);;
wrapup (get it);;

(*
THENL_SLV (THEN_SLV (APPLY_SLV LISTREL_CONS) CONJ_SLV)
  [EVAL_SLV; EVAL_SLV]
  (dest_mgoal `??a. LISTREL MATCHSYMB [Symbol "x"] [a]`);;
wrapup (get it);;

THEN_SLV (APPLY_SLV LISTREL_CONS) EVAL_SLV
  (dest_mgoal `??a. LISTREL MATCHSYMB [Symbol "x"] [a]`);;
wrapup (get it);;

EVAL_SLV
  (dest_mgoal `??a. LISTREL MATCHSYMB [Symbol "x"] [a]`);;
wrapup (get it);;
*)
