(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

let ALL2_RULES = prove
 (`(!R:A->B->bool. ALL2 R [] []) /\
   (!R h:A h':B t t'. R h h' /\ ALL2 R t t'
                      ==> ALL2 R (CONS h t) (CONS h' t'))`,
  REWRITE_TAC[ALL2]);;

let ALL2_NIL,ALL2_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] ALL2_RULES);;

(* Rev-Assoc relation. *)
let RELASSOC_RULES,RELASSOC_INDUCT,RELASSOC_CASES = new_inductive_definition
  `(!k:A v:B l. RELASSOC k (CONS (v,k) l) v) /\
   (!k k' v v' l. ~(k = k') /\ RELASSOC k l v'
                  ==> RELASSOC k (CONS (v,k') l) v')`;;

let RELASSOC_HEAD,REALASSOC_TAIL = CONJ_PAIR RELASSOC_RULES;;

(* Zip-relation. *)
let ZIPPED_RULES,ZIPPED_INDUCT,ZIPPED_CASES = new_inductive_definition
  `ZIPPED [] [] [] /\
   (!x xs y ys zs. ZIPPED xs ys zs
                   ==> ZIPPED (CONS x xs) (CONS y ys) (CONS (x,y) zs))`;;

let ZIPPED_NIL,ZIPPED_CONS = CONJ_PAIR ZIPPED_RULES;;

(* ------------------------------------------------------------------------- *)
(* Helpers for sexp analyis.                                                 *)
(* ------------------------------------------------------------------------- *)

(* Matcher for lisp-like lambda forms. *)
let MATCHPROC_RULES,MATCHPROC_INDUCT,MATCHPROC_CASES = new_inductive_definition
  `!sexp vlist vars body.
     MATCHTAGGED "lambda" sexp [List vlist; body] /\
     ALL2 MATCHSYMB vlist vars
     ==> MATCHPROC sexp vars body`;;

let _ = prove
 (`MATCHPROC '(lambda (x y) (p x y)) ["x"; "y"] '(p x y)`,
  GEN_REWRITE_TAC I [MATCHPROC_CASES] THEN
  EXISTS_TAC `[Symbol "x"; Symbol "y"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHSYMB_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_ACCEPT_TAC MATCHSYMB_RULES; MATCH_ACCEPT_TAC ALL2_NIL]);;

let MATCHBETA_RULES,MATCHBETA_INDUCT,MATCHBETA_CASES = new_inductive_definition
  `!fn vars args body.
      MATCHPROC fn vars body
      ==> MATCHBETA (List (CONS fn args)) vars body args`;;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES,EVAL_INDUCT,EVAL_CASES = new_inductive_definition
  `(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
   (!env env' env'' fn fn' vars body args args' ret.
       EVAL env fn fn' /\ MATCHPROC fn' vars body /\
       ALL2 (EVAL env) args args' /\
       ZIPPED args' vars env' /\
       env'' IS APPEND env' env /\
       EVAL env'' body ret
       ==> EVAL env (List (CONS fn args)) ret) /\
   (!env rest. EVAL env (List (CONS (Symbol "lambda") rest))
                       (List (CONS (Symbol "lambda") rest))) /\
   (!env sexp l l'. MATCHTAGGED "list" sexp l /\ ALL2 (EVAL env) l l'
                    ==> EVAL env sexp (List l')) /\
   (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                      ==> EVAL env sexp quoted)`;;

let [EVAL_SYMB; EVAL_APP; EVAL_LAMBDA; EVAL_LIST; EVAL_QUOTED] =
  CONJUNCTS EVAL_RULES;;

(* ------------------------------------------------------------------------- *)
(* The classical quine in scheme.  Note that our evaluation do not use       *)
(* dynamic (non-static) scope. But this code do not depend on this.          *)
(*                                                                           *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

(*
let QUINE = prove
 (`let quine = '((lambda (x) (list x (list (quote quote) x)))
                 (quote (lambda (x) (list x (list (quote quote) x))))) in
   EVAL [] quine quine`,
  LET_TAC THEN POP_ASSUM SUBST_VAR_TAC THEN
  MATCH_MP_TAC EVAL_BETA THEN
  REWRITE_TAC[APPEND_NIL; IMP_CONJ; RIGHT_EXISTS_AND_THM] THEN
  MAP_EVERY EXISTS_TAC
   [`['(lambda (x) (list x (list (quote quote) x))), "x"]`;
    `["x"]`;
    `'(list x (list (quote quote) x))`;
    `['(quote (lambda (x) (list x (list (quote quote) x))))]`] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC MATCHBETA_RULES THEN MATCH_MP_TAC MATCHPROC_RULES THEN
   EXISTS_TAC `[Symbol "x"]` THEN
   CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
   MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL; MATCHSYMB_RULES];
   ALL_TAC] THEN
  EXISTS_TAC `['(lambda (x) (list x (list (quote quote) x)))]` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
   MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ZIPPED_CONS THEN MATCH_ACCEPT_TAC ZIPPED_NIL; ALL_TAC] THEN
  MATCH_MP_TAC EVAL_LIST THEN
  EXISTS_TAC `[Symbol "x"; '(list (quote quote) x)]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
  MATCH_MP_TAC EVAL_LIST THEN EXISTS_TAC `['(quote quote); Symbol "x"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
  MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD);;
*)

(* ------------------------------------------------------------------------- *)
(* Prolog-style program for the evaluation of lisp expressions.              *)
(* ------------------------------------------------------------------------- *)

let BOOL_EQ_CLAUSES = ITAUT `~(T = F) /\ ~(F = T)`;;

let APPEND_RULES = prove
 (`(!xs:A list. APPEND [] xs = xs) /\
   (!x xs ys zs. APPEND xs ys = zs ==> APPEND (CONS x xs) ys = CONS x zs)`,
  REWRITE_TAC[APPEND; CONS_11]);;

let EVAL_SLV = PROLOG_SLV (REWRITE_CONV[APPEND; APPEND_NIL])
  [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL];;
let lispeval = solve EVAL_SLV;;

(* Test APPEND *)
take 10 (lispeval `??ret. APPEND [1] [2] = ret`);;
take 10 (lispeval `??ret. APPEND [1;3] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [2;4;5] [] = ret`);;

(* Test MATCHSYMB *)
take 10 (lispeval `??ret. MATCHSYMB (Symbol "a") ret`);;
take 10 (lispeval `??ret. MATCHSYMB ret "a"`);;
take 10 (lispeval `??ret. MATCHSYMB '(a b) ret`);;

(* Test MATCHTAGGED *)
take 10 (lispeval `??s ret. MATCHTAGGED s '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "tag" '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "list" '(tag x y) ret`);;

(* Test ALL2 *)
take 10 (lispeval `??a. a = 1`);;
take 10 (lispeval `??a. ALL2 (=) [] a`);;
take 10 (lispeval `??a. ALL2 (=) a []`);;
take 10 (lispeval `??a. ALL2 (=) [1] [a]`);;
take 10 (lispeval `??a. ALL2 (=) [1] a`);;
take 3 (lispeval `??a b. ALL2 (=) a b`);;

(* Test RELASSOC *)
take 10 (lispeval `??k ret. RELASSOC k [0,T; 1,F] ret`);;
take 10 (lispeval `??k. RELASSOC k [0,T; 1,F] 1`);;

(* Test ZIPPED *)
take 10 (lispeval `??ret. ZIPPED [] [] ret`);;
take 10 (lispeval `??ret. ZIPPED [] ret []`);;
take 10 (lispeval `??ret. ZIPPED [1] [T] ret`);;
take 10 (lispeval `??ret. ZIPPED [1] ret [1,T]`);;

(* Test MATCHPROC *)
take 10 (lispeval `??vars body. MATCHPROC '(lambda (x) (x x)) vars body`);;

(* Test MATCHBETA_RULES *)
take 10 (lispeval
  `??vars body args.
      MATCHBETA '((lambda (x) body) arg) vars body args`);;

take 10 (lispeval
  `??ret. EVAL [Symbol "a","x"] (Symbol "x") ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list) ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list (list)) ret`);;
take 10 (lispeval
  `??ret. EVAL [Symbol "x", "a"] '(list a) ret`);;

(snd o get o lispeval) `??ret. EVAL [] '((lambda (x) x) (list)) ret`;;
(snd o get o lispeval) `??ret. EVAL [Symbol "a","x"] '(list x) ret`;;

(snd o get o lispeval)
  `??ret. EVAL []
            '((lambda (x) (list x (list (quote quote) x)))
              (quote (lambda (x) (list x (list (quote quote) x)))))
            ret`;;

(* ------------------------------------------------------------------------- *)
(* Automatic quine generation.                                               *)
(* ------------------------------------------------------------------------- *)

let STRING_RULES,STRING_INDUCT,STRING_CASES = new_inductive_definition
  `STRING "quote" /\
   STRING "x"`;;

take 5 (solve(PROLOG_SLV NO_CONV [STRING_RULES]) `??s. STRING s`);;

let LISTOF_RULES,LISTOF_INDUCT,LISTOF_CASES = new_inductive_definition
  `LISTOF P [] /\
   (!h:A t. P h /\ LISTOF P t ==> LISTOF P (CONS h t))`;;

let LISTOF_STRING_RULES =
  ISPEC `STRING` LISTOF_RULES;;

map snd (take 20 (solve (PROLOG_SLV NO_CONV [STRING_RULES; LISTOF_STRING_RULES])
               `??l. LISTOF STRING l`));;

let LISPTERM_RULES',LISPTERM_INDUCT',LISPTERM_CASES' = new_inductive_definition
  `(!s. STRING s ==> LISPTERM (Symbol s)) /\
   (!l. LISTOF LISPTERM l ==> LISPTERM (List l)) /\
   (!l. LISTOF LISPTERM l ==> LISPTERM (List (CONS (Symbol "list") l))) /\
   (!vars vars' body.
      LISTOF STRING vars /\ vars' IS MAP Symbol vars /\ LISPTERM body
      ==> LISPTERM (List [Symbol "lambda"; List vars'; body]))`;;

let [hp] = hyp LISPTERM_RULES';;
g hp;;
e CHEAT_TAC;;
let th = top_thm();;
let LISPTERM_RULES = PROVE_HYP th LISPTERM_RULES';;
let LISPTERM_INDUCT = PROVE_HYP th LISPTERM_INDUCT';;
let LISPTERM_CASES = PROVE_HYP th LISPTERM_CASES';;

let [LISPTERM_SYMBOL;LISPTERM_LIST;LISPTERM_APP;LISPTERM_LAMBDA] =
  CONJUNCTS LISPTERM_RULES;;

(*
GEN_TAC THEN FIX_TAC "[P]" THEN REPEAT STRIP_TAC THEN
REPEAT (FIRST_X_ASSUM SUBST_VAR_TAC) THEN
ASM_REWRITE_TAC[injectivity "sexp"; distinctness "sexp"; UNWIND_THM1]

 STRUCT_CASES_TAC (ISPEC `l:sexp list` (cases "list")) THEN REWRITE_TAC[LISTOF_RULES; CONS_11] THEN
  STRUCT_CASES_TAC (SPEC `a0:sexp` (CONJUNCT1 (cases "sexp"))) THEN REWRITE_TAC[injectivity "sexp"; distinctness "sexp"]
   ASM_CASES_TAC `a = "lambda"` THEN
*)


let LISTOF_LISPTERM_RULES = ISPEC `LISPTERM` LISTOF_RULES;;

let QUINE_RULES,QUINE_INDUCT,QUINE_CASES = new_inductive_definition
  `!x y. LISPTERM x /\ LISPTERM y /\ EVAL [] (List [x; y]) (List [x; y])
         ==> QUINE (List [x; y])`;;

let EVAL_SLV = PROLOG_SLV (REWRITE_CONV[APPEND; APPEND_NIL; MAP])
  [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL; STRING_RULES;
   LISTOF_STRING_RULES; LISPTERM_RULES; LISTOF_LISPTERM_RULES; QUINE_RULES];;
let lispeval = solve EVAL_SLV;;

map snd (take 20 (solve EVAL_SLV `??l. LISTOF STRING l`));;
map snd (take 20 (solve EVAL_SLV `??x. LISPTERM x`));;
map snd (take 30 (solve EVAL_SLV `??x y. LISPTERM (List [x; y])`));;
map snd (take 20 (solve EVAL_SLV `??ret. EVAL [] '(lambda () list) ret`));;

map snd (take 1 (solve EVAL_SLV `LISPTERM (Symbol "x")`));;
map snd (take 1 (solve EVAL_SLV `LISPTERM (Symbol "y")`));;
map snd (take 1 (solve EVAL_SLV `LISPTERM '(x y)`));;

map snd (take 1 (solve EVAL_SLV
  `LISPTERM '(lambda (x) (list x (list (quote quote) x)))`));;

map snd (take 1 (solve EVAL_SLV
  `QUINE
    '((lambda (x) (list x (list (quote quote) x)))
      (quote (lambda (x) (list x (list (quote quote) x)))))`));;

(* ------------------------------------------------------------------------- *)
(* Ricerca del quine.  Ancora non funziona.  Vedi sotto.                     *)
(* ------------------------------------------------------------------------- *)

(*
map snd (take 1 (solve EVAL_SLV `??x. QUINE x`));;
*)

(* Problema: diverge! *)
(*
map snd (take 2 (solve EVAL_SLV
  `LISPTERM (List [Symbol "lambda"; '(x); Symbol "x"])`));;

g `LISPTERM (List [Symbol "lambda"; '(x); Symbol "x"])`;;
GEN_REWRITE_TAC I [LISPTERM_CASES]
REWRITE_TAC[distinctness "sexp"; injectivity "sexp"; UNWIND_THM1]
DISJ2_TAC
REWRITE_TAC[CONS_11; NOT_CONS_NIL]
EXISTS_TAC `["x":string]`
EXISTS_TAC `[Symbol "x"]`
EXISTS_TAC `Symbol "x"`
REWRITE_TAC[IS_DEF; MAP]
CONJ_TAC
MATCH_MP_TAC (CONJUNCT2 (REWRITE_RULE[FORALL_AND_THM] LISTOF_RULES))
MESON_TAC[STRING_RULES; LISTOF_STRING_RULES]
MESON_TAC[STRING_RULES; LISPTERM_RULES]
*)

(* Anche questi! *)
(*
(* Problema: diverge! *)
map snd (take 2 (solve EVAL_SLV
  `??a b. LISPTERM (List [List [Symbol "lambda"; '(x); a]; b])`));;

(* Problema: diverge! *)
map snd (take 2 (solve EVAL_SLV
  `??a. LISPTERM (List [Symbol "lambda"; '(x); a])`));;
*)
