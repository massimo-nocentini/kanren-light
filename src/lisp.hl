(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

(* Non serve, basta ALL2 *)
let LISTREL_RULES,LISTREL_INDUCT,LISTREL_CASES = new_inductive_definition
  `LISTREL R [] [] /\
   (!h h':A t t'. R h h' /\ LISTREL R t t'
                  ==> LISTREL R (CONS h t) (CONS h' t'))`;;

let LISTREL_NIL,LISTREL_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] LISTREL_RULES);;

let LISTREL_MONO = prove
  (`!R R' l m. (!x:A y:B. R x y ==> R' x y) /\ LISTREL R l m
               ==> LISTREL R' l m`,
   REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN
   DISCH_TAC THEN MATCH_MP_TAC LISTREL_INDUCT THEN
   ASM_MESON_TAC[LISTREL_RULES]);;

(* Rev-Assoc relation. *)
let RELASSOC_RULES,RELASSOC_INDUCT,RELASSOC_CASES = new_inductive_definition
  `(!k:A v:B l. RELASSOC k (CONS (v,k) l) v) /\
   (!k k' v v' l. ~(k = k') /\ RELASSOC k l v'
                  ==> RELASSOC k (CONS (v,k') l) v')`;;

let RELASSOC_HEAD,REALASSOC_TAIL = CONJ_PAIR RELASSOC_RULES;;

(* Zip-relation. *)
let ZIPPED_RULES,ZIPPED_INDUCT,ZIPPED_CASES = new_inductive_definition
  `ZIPPED [] [] [] /\
   (!x xs y ys zs. ZIPPED xs ys zs
                   ==> ZIPPED (CONS x xs) (CONS y ys) (CONS (x,y) zs))`;;

let ZIPPED_NIL,ZIPPED_CONS = CONJ_PAIR ZIPPED_RULES;;

(* ------------------------------------------------------------------------- *)
(* Helpers for sexp analyis.                                                 *)
(* ------------------------------------------------------------------------- *)

(* Matcher for lisp-like lambda forms. *)
let MATCHPROC_RULES,MATCHPROC_INDUCT,MATCHPROC_CASES = new_inductive_definition
  `!sexp vlist vars body.
     MATCHTAGGED "lambda" sexp [List vlist; body] /\
     LISTREL MATCHSYMB vlist vars
     ==> MATCHPROC sexp vars body`;;

let _ = prove
 (`MATCHPROC '(lambda (x y) (p x y)) ["x"; "y"] '(p x y)`,
  GEN_REWRITE_TAC I [MATCHPROC_CASES] THEN
  EXISTS_TAC `[Symbol "x"; Symbol "y"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHSYMB_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN CONJ_TAC THENL
  [MATCH_ACCEPT_TAC MATCHSYMB_RULES; MATCH_ACCEPT_TAC LISTREL_NIL]);;

let MATCHBETA_RULES,MATCHBETA_INDUCT,MATCHBETA_CASES = new_inductive_definition
  `!fn vars args body.
      MATCHPROC fn vars body
      ==> MATCHBETA (List (CONS fn args)) vars body args`;;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES_OLD,EVAL_INDUCT,EVAL_CASES =
  let EVAL_RULES',EVAL_INDUCT',EVAL_CASES' = new_inductive_definition
    `(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
     (!env env' sexp vars body args args' ret.
         MATCHBETA sexp vars body args /\ LISTREL (EVAL env) args args' /\
         ZIPPED args' vars env' /\ EVAL (APPEND env' env) body ret
         ==> EVAL env sexp ret) /\
     (!env sexp l l'. MATCHTAGGED "list" sexp l /\ LISTREL (EVAL env) l l'
                      ==> EVAL env sexp (List l')) /\
     (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                        ==> EVAL env sexp quoted)` in
  let pth = prove
   (hd (hyp EVAL_RULES'),
    MESON_TAC[injectivity "sexp"; LISTREL_MONO]) in
  PROVE_HYP pth EVAL_RULES',
  PROVE_HYP pth EVAL_INDUCT',
  PROVE_HYP pth EVAL_CASES';;

let [EVAL_SYMB; EVAL_BETA; EVAL_LIST; EVAL_QUOTED] = CONJUNCTS EVAL_RULES_OLD;;

(* ------------------------------------------------------------------------- *)
(* The classical quine in scheme.  Note that our evaluation do not use       *)
(* dynamic (non-static) scope. But this code do not depend on this.          *)
(*                                                                           *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

let QUINE = prove
 (`let quine = '((lambda (x) (list x (list (quote quote) x)))
                 (quote (lambda (x) (list x (list (quote quote) x))))) in
   EVAL [] quine quine`,
  LET_TAC THEN POP_ASSUM SUBST_VAR_TAC THEN
  MATCH_MP_TAC EVAL_BETA THEN
  REWRITE_TAC[APPEND_NIL; IMP_CONJ; RIGHT_EXISTS_AND_THM] THEN
  MAP_EVERY EXISTS_TAC
   [`['(lambda (x) (list x (list (quote quote) x))), "x"]`;
    `["x"]`;
    `'(list x (list (quote quote) x))`;
    `['(quote (lambda (x) (list x (list (quote quote) x))))]`] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC MATCHBETA_RULES THEN MATCH_MP_TAC MATCHPROC_RULES THEN
   EXISTS_TAC `[Symbol "x"]` THEN
   CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
   MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL; MATCHSYMB_RULES];
   ALL_TAC] THEN
  EXISTS_TAC `['(lambda (x) (list x (list (quote quote) x)))]` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL] THEN
   MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ZIPPED_CONS THEN MATCH_ACCEPT_TAC ZIPPED_NIL; ALL_TAC] THEN
  MATCH_MP_TAC EVAL_LIST THEN
  EXISTS_TAC `[Symbol "x"; '(list (quote quote) x)]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL] THEN
  MATCH_MP_TAC EVAL_LIST THEN EXISTS_TAC `['(quote quote); Symbol "x"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  MATCH_MP_TAC LISTREL_CONS THEN REWRITE_TAC[LISTREL_NIL] THEN
  MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD);;

let EVAL_RULES = prove
 (`(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
   (!env env' env'' sexp vars body args args' ret.
       MATCHBETA sexp vars body args /\ LISTREL (EVAL env) args args' /\
       ZIPPED args' vars env' /\ env'' IS APPEND env' env /\
       EVAL env'' body ret
       ==> EVAL env sexp ret) /\
   (!env sexp l l'. MATCHTAGGED "list" sexp l /\ LISTREL (EVAL env) l l'
                    ==> EVAL env sexp (List l')) /\
   (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                        ==> EVAL env sexp quoted)`,
  REWRITE_TAC[EVAL_RULES_OLD; IS_DEF] THEN MESON_TAC[EVAL_RULES_OLD]);;

let [EVAL_SYMB; EVAL_BETA; EVAL_LIST; EVAL_QUOTED] = CONJUNCTS EVAL_RULES;;

(* ------------------------------------------------------------------------- *)
(* Prolog-style program for the evaluation of lisp programs.                 *)
(* ------------------------------------------------------------------------- *)

let BOOL_EQ_CLAUSES = ITAUT `~(T = F) /\ ~(F = T)`;;

let APPEND_RULES = prove
 (`(!xs:A list. APPEND [] xs = xs) /\
   (!x xs ys zs. APPEND xs ys = zs ==> APPEND (CONS x xs) ys = CONS x zs)`,
  REWRITE_TAC[APPEND; CONS_11]);;

let EVAL_SLV = PROLOG_SLV
  [MATCHSYMB_RULES; MATCHTAGGED_RULES;
   REWRITE_RULE[FORALL_AND_THM] LISTREL_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL];;
let lispeval = solve EVAL_SLV;;

(* Test APPEND *)
take 10 (lispeval `??ret. APPEND [1] [2] = ret`);;
take 10 (lispeval `??ret. APPEND [1;3] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [2;4;5] [] = ret`);;

(* Test MATCHSYMB *)
take 10 (lispeval `??ret. MATCHSYMB (Symbol "a") ret`);;
take 10 (lispeval `??ret. MATCHSYMB ret "a"`);;
take 10 (lispeval `??ret. MATCHSYMB '(a b) ret`);;

(* Test MATCHTAGGED *)
take 10 (lispeval `??s ret. MATCHTAGGED s '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "tag" '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "list" '(tag x y) ret`);;

(* Test LISTREL *)
take 10 (lispeval `??a. a = 1`);;
take 10 (lispeval `??a. LISTREL (=) [] a`);;
take 10 (lispeval `??a. LISTREL (=) a []`);;
take 10 (lispeval `??a. LISTREL (=) [1] [a]`);;
take 10 (lispeval `??a. LISTREL (=) [1] a`);;
take 3 (lispeval `??a b. LISTREL (=) a b`);;

(* Test RELASSOC *)
take 10 (lispeval `??k ret. RELASSOC k [0,T; 1,F] ret`);;
take 10 (lispeval `??k. RELASSOC k [0,T; 1,F] 1`);;

(* Test ZIPPED *)
take 10 (lispeval `??ret. ZIPPED [] [] ret`);;
take 10 (lispeval `??ret. ZIPPED [] ret []`);;
take 10 (lispeval `??ret. ZIPPED [1] [T] ret`);;
take 10 (lispeval `??ret. ZIPPED [1] ret [1,T]`);;

(* Test MATCHPROC *)
take 10 (lispeval `??vars body. MATCHPROC '(lambda (x) (x x)) vars body`);;

(* Test MATCHBETA_RULES *)
take 10 (lispeval
  `??vars body args.
      MATCHBETA '((lambda (x) body) arg) vars body args`);;

take 10 (lispeval
  `??ret. EVAL [Symbol "a","x"] (Symbol "x") ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list) ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list (list)) ret`);;
take 10 (lispeval
  `??ret. EVAL [Symbol "x", "a"] '(list a) ret`);;

(snd o get o lispeval) `??ret. EVAL [] '((lambda (x) x) (list)) ret`;;
(snd o get o lispeval) `??ret. EVAL [Symbol "a","x"] '(list x) ret`;;

(snd o get o lispeval)
  `??ret. EVAL []
            '((lambda (x) (list x (list (quote quote) x)))
              (quote (lambda (x) (list x (list (quote quote) x)))))
            ret`;;
