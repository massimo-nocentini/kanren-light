(* ========================================================================= *)
(* Lispish meta-circular evaluator.                                          *)
(* ========================================================================= *)

(* ------------------------------------------------------------------------- *)
(* Misc list helper theory.                                                  *)
(* ------------------------------------------------------------------------- *)

let ALL2_RULES = prove
 (`(!R:A->B->bool. ALL2 R [] []) /\
   (!R h:A h':B t t'. R h h' /\ ALL2 R t t'
                      ==> ALL2 R (CONS h t) (CONS h' t'))`,
  REWRITE_TAC[ALL2]);;

let ALL2_NIL,ALL2_CONS =
  CONJ_PAIR (REWRITE_RULE [FORALL_AND_THM] ALL2_RULES);;

(* Rev-Assoc relation. *)
let RELASSOC_RULES,RELASSOC_INDUCT,RELASSOC_CASES = new_inductive_definition
  `(!k:A v:B l. RELASSOC k (CONS (v,k) l) v) /\
   (!k k' v v' l. ~(k = k') /\ RELASSOC k l v'
                  ==> RELASSOC k (CONS (v,k') l) v')`;;

let RELASSOC_HEAD,REALASSOC_TAIL = CONJ_PAIR RELASSOC_RULES;;

(* Zip-relation. *)
let ZIPPED_RULES,ZIPPED_INDUCT,ZIPPED_CASES = new_inductive_definition
  `ZIPPED [] [] [] /\
   (!x xs y ys zs. ZIPPED xs ys zs
                   ==> ZIPPED (CONS x xs) (CONS y ys) (CONS (x,y) zs))`;;

let ZIPPED_NIL,ZIPPED_CONS = CONJ_PAIR ZIPPED_RULES;;

(* ------------------------------------------------------------------------- *)
(* Helpers for sexp analyis.                                                 *)
(* ------------------------------------------------------------------------- *)

(* Matcher for lisp-like lambda forms. *)
let MATCHPROC_RULES,MATCHPROC_INDUCT,MATCHPROC_CASES = new_inductive_definition
  `!sexp vlist vars body.
     MATCHTAGGED "lambda" sexp [List vlist; body] /\
     ALL2 MATCHSYMB vlist vars
     ==> MATCHPROC sexp vars body`;;

let _ = prove
 (`MATCHPROC '(lambda (x y) (p x y)) ["x"; "y"] '(p x y)`,
  GEN_REWRITE_TAC I [MATCHPROC_CASES] THEN
  EXISTS_TAC `[Symbol "x"; Symbol "y"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHSYMB_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_ACCEPT_TAC MATCHSYMB_RULES; MATCH_ACCEPT_TAC ALL2_NIL]);;

let MATCHBETA_RULES,MATCHBETA_INDUCT,MATCHBETA_CASES = new_inductive_definition
  `!fn vars args body.
      MATCHPROC fn vars body
      ==> MATCHBETA (List (CONS fn args)) vars body args`;;

(* ------------------------------------------------------------------------- *)
(* Evaluation.                                                               *)
(* ------------------------------------------------------------------------- *)

let EVAL_RULES_OLD,EVAL_INDUCT,EVAL_CASES = new_inductive_definition
    `(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
     (!env env' sexp vars body args args' ret.
         MATCHBETA sexp vars body args /\ ALL2 (EVAL env) args args' /\
         ZIPPED args' vars env' /\ EVAL (APPEND env' env) body ret
         ==> EVAL env sexp ret) /\
     (!env sexp l l'. MATCHTAGGED "list" sexp l /\ ALL2 (EVAL env) l l'
                      ==> EVAL env sexp (List l')) /\
     (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                        ==> EVAL env sexp quoted)`;;

let [EVAL_SYMB; EVAL_BETA; EVAL_LIST; EVAL_QUOTED] = CONJUNCTS EVAL_RULES_OLD;;

(* ------------------------------------------------------------------------- *)
(* The classical quine in scheme.  Note that our evaluation do not use       *)
(* dynamic (non-static) scope. But this code do not depend on this.          *)
(*                                                                           *)
(* (define quinec                                                            *)
(*   '((lambda (x) (list x (list (quote quote) x)))                          *)
(*     (quote                                                                *)
(*       (lambda (x) (list x (list (quote quote) x))))))                     *)
(* ------------------------------------------------------------------------- *)

(*
let QUINE = prove
 (`let quine = '((lambda (x) (list x (list (quote quote) x)))
                 (quote (lambda (x) (list x (list (quote quote) x))))) in
   EVAL [] quine quine`,
  LET_TAC THEN POP_ASSUM SUBST_VAR_TAC THEN
  MATCH_MP_TAC EVAL_BETA THEN
  REWRITE_TAC[APPEND_NIL; IMP_CONJ; RIGHT_EXISTS_AND_THM] THEN
  MAP_EVERY EXISTS_TAC
   [`['(lambda (x) (list x (list (quote quote) x))), "x"]`;
    `["x"]`;
    `'(list x (list (quote quote) x))`;
    `['(quote (lambda (x) (list x (list (quote quote) x))))]`] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC MATCHBETA_RULES THEN MATCH_MP_TAC MATCHPROC_RULES THEN
   EXISTS_TAC `[Symbol "x"]` THEN
   CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
   MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL; MATCHSYMB_RULES];
   ALL_TAC] THEN
  EXISTS_TAC `['(lambda (x) (list x (list (quote quote) x)))]` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
   MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC ZIPPED_CONS THEN MATCH_ACCEPT_TAC ZIPPED_NIL; ALL_TAC] THEN
  MATCH_MP_TAC EVAL_LIST THEN
  EXISTS_TAC `[Symbol "x"; '(list (quote quote) x)]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
  MATCH_MP_TAC EVAL_LIST THEN EXISTS_TAC `['(quote quote); Symbol "x"]` THEN
  CONJ_TAC THENL [MATCH_ACCEPT_TAC MATCHTAGGED_RULES; ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN CONJ_TAC THENL
  [MATCH_MP_TAC EVAL_QUOTED THEN MATCH_ACCEPT_TAC MATCHTAGGED_RULES;
   ALL_TAC] THEN
  MATCH_MP_TAC ALL2_CONS THEN REWRITE_TAC[ALL2_NIL] THEN
  MATCH_MP_TAC EVAL_SYMB THEN MATCH_ACCEPT_TAC RELASSOC_HEAD);;
*)

let EVAL_RULES = prove
 (`(!env a x. RELASSOC a env x ==> EVAL env (Symbol a) x) /\
   (!env env' env'' sexp vars body args args' ret.
       MATCHBETA sexp vars body args /\ ALL2 (EVAL env) args args' /\
       ZIPPED args' vars env' /\ env'' IS APPEND env' env /\
       EVAL env'' body ret
       ==> EVAL env sexp ret) /\
   (!env sexp l l'. MATCHTAGGED "list" sexp l /\ ALL2 (EVAL env) l l'
                    ==> EVAL env sexp (List l')) /\
   (!env sexp quoted. MATCHTAGGED "quote" sexp [quoted]
                        ==> EVAL env sexp quoted)`,
  REWRITE_TAC[EVAL_RULES_OLD; IS_DEF] THEN MESON_TAC[EVAL_RULES_OLD]);;

let [EVAL_SYMB; EVAL_BETA; EVAL_LIST; EVAL_QUOTED] = CONJUNCTS EVAL_RULES;;

(* ------------------------------------------------------------------------- *)
(* Prolog-style program for the evaluation of lisp programs.                 *)
(* ------------------------------------------------------------------------- *)

let BOOL_EQ_CLAUSES = ITAUT `~(T = F) /\ ~(F = T)`;;

let APPEND_RULES = prove
 (`(!xs:A list. APPEND [] xs = xs) /\
   (!x xs ys zs. APPEND xs ys = zs ==> APPEND (CONS x xs) ys = CONS x zs)`,
  REWRITE_TAC[APPEND; CONS_11]);;

let EVAL_SLV = PROLOG_SLV (REWRITE_CONV[APPEND; APPEND_NIL])
  [MATCHSYMB_RULES; MATCHTAGGED_RULES; ALL2_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL];;
let lispeval = solve EVAL_SLV;;

(* Test APPEND *)
take 10 (lispeval `??ret. APPEND [1] [2] = ret`);;
take 10 (lispeval `??ret. APPEND [1;3] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [] [2;4;5] = ret`);;
take 10 (lispeval `??ret. APPEND [2;4;5] [] = ret`);;

(* Test MATCHSYMB *)
take 10 (lispeval `??ret. MATCHSYMB (Symbol "a") ret`);;
take 10 (lispeval `??ret. MATCHSYMB ret "a"`);;
take 10 (lispeval `??ret. MATCHSYMB '(a b) ret`);;

(* Test MATCHTAGGED *)
take 10 (lispeval `??s ret. MATCHTAGGED s '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "tag" '(tag x y) ret`);;
take 10 (lispeval `??ret. MATCHTAGGED "list" '(tag x y) ret`);;

(* Test ALL2 *)
take 10 (lispeval `??a. a = 1`);;
take 10 (lispeval `??a. ALL2 (=) [] a`);;
take 10 (lispeval `??a. ALL2 (=) a []`);;
take 10 (lispeval `??a. ALL2 (=) [1] [a]`);;
take 10 (lispeval `??a. ALL2 (=) [1] a`);;
take 3 (lispeval `??a b. ALL2 (=) a b`);;

(* Test RELASSOC *)
take 10 (lispeval `??k ret. RELASSOC k [0,T; 1,F] ret`);;
take 10 (lispeval `??k. RELASSOC k [0,T; 1,F] 1`);;

(* Test ZIPPED *)
take 10 (lispeval `??ret. ZIPPED [] [] ret`);;
take 10 (lispeval `??ret. ZIPPED [] ret []`);;
take 10 (lispeval `??ret. ZIPPED [1] [T] ret`);;
take 10 (lispeval `??ret. ZIPPED [1] ret [1,T]`);;

(* Test MATCHPROC *)
take 10 (lispeval `??vars body. MATCHPROC '(lambda (x) (x x)) vars body`);;

(* Test MATCHBETA_RULES *)
take 10 (lispeval
  `??vars body args.
      MATCHBETA '((lambda (x) body) arg) vars body args`);;

take 10 (lispeval
  `??ret. EVAL [Symbol "a","x"] (Symbol "x") ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list) ret`);;
take 10 (lispeval
  `??ret. EVAL [] '(list (list)) ret`);;
take 10 (lispeval
  `??ret. EVAL [Symbol "x", "a"] '(list a) ret`);;

(snd o get o lispeval) `??ret. EVAL [] '((lambda (x) x) (list)) ret`;;
(snd o get o lispeval) `??ret. EVAL [Symbol "a","x"] '(list x) ret`;;

(snd o get o lispeval)
  `??ret. EVAL []
            '((lambda (x) (list x (list (quote quote) x)))
              (quote (lambda (x) (list x (list (quote quote) x)))))
            ret`;;

(* ------------------------------------------------------------------------- *)
(* Automatic quine generation.                                               *)
(* ------------------------------------------------------------------------- *)

let STRING_RULES,STRING_INDUCT,STRING_CASES = new_inductive_definition
  `STRING "list" /\
   STRING "quote" /\
   STRING "x" /\
   STRING "y"`;;

take 5 (solve(PROLOG_SLV NO_CONV [STRING_RULES]) `??s. STRING s`);;

let LISTOF_RULES,LISTOF_INDUCT,LISTOF_CASES = new_inductive_definition
  `LISTOF P [] /\
   (!h:A t. P h /\ LISTOF P t ==> LISTOF P (CONS h t))`;;

let LISTOF_STRING_RULES =
  ISPEC `STRING` LISTOF_RULES;;

take 10 (solve (PROLOG_SLV NO_CONV [STRING_RULES; LISTOF_STRING_RULES])
               `??l. LISTOF STRING l`);;

let LISPTERM_RULES,LISPTERM_INDUCT,LISPTERM_CASES = new_inductive_definition
  `(!s. STRING s ==> LISPTERM (Symbol s)) /\
   (!l. LISTOF LISPTERM l ==> LISPTERM (List l)) /\
   (!vars vars' body.
      LISTOF STRING vars /\ vars' IS MAP Symbol vars /\ LISPTERM body
      ==> LISPTERM (List [Symbol "lambda"; List vars'; body]))`;;

(*
let [hp] = hyp LISPTERM_RULES;;
g hp;;
GEN_TAC THEN
FIX_TAC "[P]"
REPEAT STRIP_TAC THEN
MESON_TAC[
*)

let EVAL_SLV = PROLOG_SLV (REWRITE_CONV[APPEND; APPEND_NIL])
  [MATCHSYMB_RULES; MATCHTAGGED_RULES;
   REWRITE_RULE[FORALL_AND_THM] ALL2_RULES;
   RELASSOC_RULES; ZIPPED_RULES; MATCHPROC_RULES; MATCHBETA_RULES;
   EVAL_RULES; BOOL_EQ_CLAUSES; EQ_REFL;
   LISPTERM_RULES; LISTOF_STRING_RULES; STRING_RULES];;
let lispeval = solve EVAL_SLV;;

(*
take 10 (lispeval `??tm. LISPTERM tm`);;

CONJ_SLV (dest_mgoal `??ret. LISPTERM ret /\ EVAL [] ret ret`);;

(snd o get o lispeval)
  `??ret. LISPTERM ret AND ENTAILS EVAL [] ret ret`;;
*)